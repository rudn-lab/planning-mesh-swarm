use high_level_cmds::{
    network_kit::{ConnectionInfo, NetworkKit, ReceiverNic, TransmitterNic},
    AsyncUtils,
};

pub(crate) type VirtualPeerId = u64;
pub(crate) type AckTx = oneshot::Sender<()>;

pub(crate) fn new_virtual_network_kit<const SENDER_COUNT: usize>(
    tx: async_channel::Sender<VirtualRadioRequest>,
) -> NetworkKit<
    VirtualPeerId,
    MessageType,
    VirtualReceiver,
    VirtualTransmitter,
    AsyncStdAsyncUtils,
    SENDER_COUNT,
> {
    let mut i = 0;
    let senders: [VirtualTransmitter; SENDER_COUNT] = [(); SENDER_COUNT].map(|_| {
        let instance = VirtualTransmitter::new(tx.clone(), i);
        i += 1;
        instance
    });

    NetworkKit {
        receiver: VirtualReceiver::new(tx.clone()),
        senders,
        utils: AsyncStdAsyncUtils::new(tx),
        _peer_id_type: std::marker::PhantomData,
        _message_type: std::marker::PhantomData,
    }
}

pub(crate) struct AsyncStdAsyncUtils {
    tx: async_channel::Sender<VirtualRadioRequest>,
}

impl AsyncStdAsyncUtils {
    pub(crate) fn new(tx: async_channel::Sender<VirtualRadioRequest>) -> AsyncStdAsyncUtils {
        AsyncStdAsyncUtils { tx }
    }
}

impl AsyncUtils for AsyncStdAsyncUtils {
    async fn sleep(&self, duration: core::time::Duration) {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::Sleep((duration, tx)))
            .await
            .unwrap();
        rx.await.unwrap();
    }

    async fn log(&self, data: &str) {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::Log((data.to_string(), tx)))
            .await
            .unwrap();
        rx.await.unwrap();
    }
}

/// This type is generated by the implementations here,
/// and sent into the game engine.
/// Responses from the game engine are received through oneshot channels.
///
/// Each variant represents an action that the NIC code wants to happen:
/// read this as "The NIC wants to...".
pub(crate) enum VirtualRadioRequest {
    /// Sleep for the given duration.
    Sleep((core::time::Duration, AckTx)),

    /// Add a message to the robot log.
    Log((String, AckTx)),
    /// Receive a message.
    /// Note that this might not immediately respond
    /// if there is no queued message:
    /// it is the responsibility of the game engine to batch these requests.
    Receive(oneshot::Sender<(VirtualPeerId, MessageType)>),

    /// Get the robot's own transmitter PeerId (aka its MAC address).
    GetSelfPeerId(oneshot::Sender<VirtualPeerId>),

    /// Get whether a transmitter is alive.
    /// This should return true if it's available,
    /// and false if the robot is missing this transmitter.
    Ping(usize, oneshot::Sender<bool>),

    /// Get the peer of the transmitter of the given index.
    /// This should return the full ConnectionInfo if there is a peer,
    /// None if there is no peer,
    /// and Err if there is no transmitter with this index.
    GetPeerOfTransmitter(
        usize,
        oneshot::Sender<Result<Option<ConnectionInfo<VirtualPeerId>>, ()>>,
    ),

    /// Get the list of reachable peers by the transmitter of the given index.
    /// If none are reachable, return an empty Vec.
    /// If there is no transmitter with this index, return Err.
    GetReachablePeers(usize, oneshot::Sender<Result<Vec<VirtualPeerId>, ()>>),

    /// Attempt to pair with a given peer.
    /// If successful, return true, otherwise return false.
    /// If there is no transmitter with this index, return Err.
    Pair(usize, VirtualPeerId, oneshot::Sender<Result<bool, ()>>),

    /// Attempt to unpair the NIC.
    /// If it's not paired, ignore.
    /// If there is no transmitter with this index, return Err.
    Unpair(usize, oneshot::Sender<Result<(), ()>>),

    /// Send a message to the peer that this transmitter is paired with.
    /// If there is no transmitter with this index, return Err.
    Send(usize, MessageType, oneshot::Sender<Result<(), ()>>),
}

#[derive(Copy, Clone, Debug)]
pub(crate) enum MessageType {
    Ping,
}

pub(crate) struct VirtualReceiver {
    tx: async_channel::Sender<VirtualRadioRequest>,
}

impl VirtualReceiver {
    pub(crate) fn new(tx: async_channel::Sender<VirtualRadioRequest>) -> VirtualReceiver {
        VirtualReceiver { tx }
    }
}

impl ReceiverNic<VirtualPeerId, MessageType> for VirtualReceiver {
    type Error = core::convert::Infallible;

    async fn get(&mut self) -> Result<(VirtualPeerId, MessageType), Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::Receive(tx))
            .await
            .unwrap();
        Ok(rx.await.unwrap())
    }

    async fn get_id(&mut self) -> Result<VirtualPeerId, Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::GetSelfPeerId(tx))
            .await
            .unwrap();
        Ok(rx.await.unwrap())
    }
}

pub(crate) struct VirtualTransmitter {
    tx: async_channel::Sender<VirtualRadioRequest>,
    idx: usize,
}

impl VirtualTransmitter {
    pub(crate) fn new(
        tx: async_channel::Sender<VirtualRadioRequest>,
        idx: usize,
    ) -> VirtualTransmitter {
        VirtualTransmitter { tx, idx }
    }
}

impl TransmitterNic<VirtualPeerId, MessageType> for VirtualTransmitter {
    type Error = ();

    async fn ping(&mut self) -> Result<(), Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::Ping(self.idx, tx))
            .await
            .expect("failed to send");
        match rx.await.expect("failed to receive") {
            true => Ok(()),
            false => Err(()),
        }
    }

    async fn get_peer(&mut self) -> Result<Option<VirtualPeerId>, Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::GetPeerOfTransmitter(self.idx, tx))
            .await
            .expect("failed to send");
        Ok(rx
            .await
            .expect("failed to receive")?
            .map(|info| info.peer_id))
    }

    async fn get_connection_info(
        &mut self,
    ) -> Result<high_level_cmds::network_kit::ConnectionInfo<VirtualPeerId>, Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::GetPeerOfTransmitter(self.idx, tx))
            .await
            .expect("failed to send");
        rx.await.expect("failed to receive")?.ok_or(())
    }

    async fn scan(&mut self, peers: &mut [VirtualPeerId]) -> Result<usize, Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::GetReachablePeers(self.idx, tx))
            .await
            .expect("failed to send");

        let received_peers = rx.await.expect("failed to receive")?;
        for (i, peer) in received_peers.iter().enumerate() {
            match peers.get_mut(i) {
                Some(p) => *p = *peer,
                None => break,
            }
        }

        Ok(received_peers.len())
    }

    async fn pair(&mut self, peer: VirtualPeerId) -> Result<(), Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::Pair(self.idx, peer, tx))
            .await
            .expect("failed to send");
        match rx.await.expect("failed to receive")? {
            true => Ok(()),
            false => Err(()),
        }
    }

    async fn unpair(&mut self) -> Result<(), Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::Unpair(self.idx, tx))
            .await
            .expect("failed to send");
        rx.await.expect("failed to receive")
    }

    async fn send(&mut self, message: MessageType) -> Result<(), Self::Error> {
        let (tx, rx) = oneshot::channel();
        self.tx
            .send(VirtualRadioRequest::Send(self.idx, message, tx))
            .await
            .expect("failed to send");
        rx.await.expect("failed to receive")
    }
}

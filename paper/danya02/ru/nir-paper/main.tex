%%
\documentclass[%
]{article}

\usepackage[14pt]{extsizes} % для того чтобы задать нестандартный 14-ый размер шрифта
\usepackage[left=20mm, top=15mm, right=15mm, bottom=30mm, footskip=15mm]{geometry}

\usepackage[utf8]{inputenc}

\usepackage{polyglossia}
\setdefaultlanguage[spelling=modern]{russian}
\setotherlanguages{english}

\usepackage[style=gost-numeric]{biblatex}
\usepackage{graphicx}

%\captionsetup[listing]{name=Листинг}

\setmainfont[Ligatures=TeX,Scale=MatchLowercase]{CMU Serif}
\setsansfont[Ligatures=TeX,Scale=MatchLowercase]{CMU Sans Serif}
\setmonofont[Scale=MatchLowercase]{CMU Typewriter Text}

% CMU Serif
\newfontfamily\cyrillicfont%
[Script=Cyrillic,Ligatures=TeX,Scale=MatchLowercase]%
{CMU Serif}

% CMU Sans Serif
\newfontfamily\cyrillicfontsf%
[Script=Cyrillic,Ligatures=TeX,Scale=MatchLowercase]%
{CMU Sans Serif}

% CMU Typewriter Text
\newfontfamily\cyrillicfonttt%
[Script=Cyrillic,Scale=MatchLowercase]%
{CMU Typewriter Text}


%%% One can fix some overfulls
\sloppy

%% Minted listings support
%% Need pygment <http://pygments.org/> <http://pypi.python.org/pypi/Pygments>
%\usepackage[newfloat]{minted}
\usepackage{minted}
%% auto break lines
\setminted{breaklines=true}

%\usepackage{caption}

%\newenvironment{code}{\captionsetup{type=listing}}{}
%\SetupFloatingEnvironment{listing}{name=Листинг}

\addbibresource{main.bib}

%% end of the preamble, start of the body of the document source.
\begin{document}

\selectlanguage{russian}

%%
%% Rights management information.
%% CC-BY is default license.
% \copyrightyear{2025}
% \copyrightclause{Copyright for this paper by its authors.
%   Use permitted under Creative Commons License Attribution 4.0
%   International (CC BY 4.0).}

%%
%% This command is for the conference information
% \conference{Information and Telecommunication Technologies and Mathematical Modeling of High-Tech Systems 2025 (ITTMM 2025), Moscow, April 07--11, 2025}

%%
%% The "title" command
\title{Симулятор беспроводной меш-сети для мобильных роботов}
% \title[mode=trans]{Wireless mesh network simulator for mobile robots}



% НАЧАЛО ТИТУЛЬНОГО ЛИСТА
\begin{titlepage}

  \begin{center}
  \hfill \break
  \large{РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ}\\
  \large{ИМЕНИ ПАТРИСА ЛУМУМБЫ}\\
  \normalsize{Факультет \underline{физико-математических и естественных наук}}\\ 
  \normalsize{Кафедра \underline{математического моделирования и искусственного интеллекта}}\\

  \vspace*{\fill}

  \begin{flushright}
    \large{Утверждаю}\\
    \normalsize{Заведующий кафедрой} 
    \normalsize{математического \\ моделирования и \\ искусственного интеллекта \\} 
    \underline{\phantom{signature signature}} Малых М.Д. \\
    <<\underline{\phantom{day}}>> \underline{\phantom{month month}} 2025 г.
    \end{flushright}
 
  \vspace*{\fill}
  \Large{\textbf{НАУЧНО-ИССЛЕДОВАТЕЛЬСКАЯ РАБОТА\\ на тему}}
  \\
  \underline{Моделирование поведения автономных роботов,} \\
  \underline{объединенных беспроводной меш-сетью}
  \vspace*{\fill}
  
  \end{center}
   
   \begin{flushright}
    Выполнил \\
    Студент группы \underline{НПИбд-01-21}\\
    Студенческий билет \textnumero{}: \underline{1032212280}
    \underline{Генералов Даниил Михайлович \phantom{signature}}\\ \vspace{0.5cm}
   \end{flushright}

   \vspace*{\fill}

   \begin{flushright}
    Руководитель \\
    \underline{Виноградов Андрей Николаевич \phantom{signature}}\\ \vspace{0.5cm}
   \end{flushright}
   
  \begin{center} \textbf{МОСКВА} \\ 2025 г. \end{center}
  \thispagestyle{empty} % выключаем отображение номера для этой страницы
   
  \end{titlepage}
   % КОНЕЦ ТИТУЛЬНОГО ЛИСТА
  
  \newpage


\tableofcontents

\newpage

% \tnotemark[1]
% \tnotetext[1]{You can use this document as the template for preparing your publication. We recommend using the latest version of the ittmm style.}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
% \author{Даниил М. Генералов}
% [%
% trans={Daniil M. Generalov},
% orcid=0000-0002-2337-1176,
% email=1032212280@pfur.ru,
% %url=https://yamadharma.github.io/,
% ]
% \cormark[1]

% \address[1]{Российский университет дружбы народов, ул. Миклухо-Маклая, д. 6, Москва, 117198, Российская Федерация}

% \author[1]{Андрей Н. Виноградов}[%
% trans={Andrei N. Vinogradov},
% email=vinogradov-an@rudn.ru,
% orcid=0000-0002-3349-8859,
% ]

%%% Footnotes
% \cortext[1]{Автор, отвечающий за публикацию.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
% \begin{abstract}
% В этой работе мы представляем программу-симулятор
% для разработки и тестирования алгоритмов маршрутизации
% в беспроводных меш-сетях на мобильных роботах.
% С помощью этого симулятора можно
% изучать поведение этих мобильных роботов
% при различных условиях радио-связи,
% которые трудно симулировать на физическом оборудовании.
% Код, написанный для симулятора,
% можно использовать на физических микроконтроллерах без изменений.
% Интеграция симуляции радио-связи
% и движения роботов по прямоугольной сетке
% является новым подходом,
% который сложно воспроизвести в существующих инструментах симуляции сетей.
% \end{abstract}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
% \begin{keywords}
%   меш-сеть \sep
%   MANET \sep
%   маршрутизация \sep
%   симулятор
% \end{keywords}

%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
% \maketitle

\section{Введение}
\label{sec:intro}

\subsection{Меш-сети}
Беспроводные меш-сети (MANET, \emph{Mobile Ad-hoc Network})
отличаются от традиционных радио-сетей тем,
что они не имеют центрального роутера (такого как Wi-Fi AP или сотовая базовая станция: такой дизайн также известен как \emph{hub-and-spoke});
вместо этого каждый клиент сети является также роутером для своих соседей.

На таком принципе работают рации:
каждая рация может передать сигнал тем приемникам, которые находятся в ее радиусе действия.
Сообщения могут идти дальше, чем радиус действия одного сигнала,
посредством ретрансляции:
если Алиса хочет передать сообщение Чарли,
но Алиса находится слишком далеко от него,
то Алиса может передать свое сообщение Бобу,
и Боб сможет передать сообщение дальше --
либо напрямую к Чарли, если он находится в его радиусе,
либо кому-то еще, кто находится ближе к Чарли.

Такой способ подключения напоминает широкое устройство интернета:
там тоже нет центральных роутеров,
и вместо этого каждая автономная система (AS, \emph{Autonomous System})
имеет пир-соединения (\emph{peering}) с другими AS.
Для этого администраторы двух сетей
соединяют свои роутеры друг с другом
и настраивают свою сеть так, чтобы обе стороны
могли доставлять свои пакеты через другую AS.

Таким образом сети различных организаций составляют глобальную сеть.
Автономные системы обмениваются информацией о том, какие другие системы доступны им,
с помощью протокола BGP (Border Gateway Protocol),
и на основании этой информации их роутеры решают, куда отправлять приходящий им трафик.

Устройство в беспроводной меш-сети примерно аналогично автономной системе интернета.
Однако есть одно важное отличие:
настройка пир-соединений между AS выполняется вручную
по обоюдному согласию администраторов каждой AS,
требует создания физического подключения
и настройки роутеров внутри AS.
Напротив, в беспроводной меш-сети,
устройства могут двигаться относительно друг друга и менять свою сетевую конфигурацию динамически,
так что настройка соединений между устройствами и обмен информацией
должен происходить без участия человека.

Дополнительная сложность заключается в том, что
беспроводные меш-сети часто используются в ситуациях,
когда каждое устройство имеет ограниченные вычислительные ресурсы.
Автономные системы, особенно крупные,
состоят из мощных роутеров,
которые имеют возможность хранить в памяти всю карту глобального интернета
и быстро использовать ее для поиска маршрутов.
Беспроводные меш-сети, напротив, используются в тех ситуациях,
когда есть задача использовать более простое оборудование,
например смартфоны или даже микроконтроллеры:
они не всегда имеют возможность хранить полную карту своей сети,
и поэтому должны использовать подходы для работы с ограниченными ресурсами.

Меш-сети сложнее для разработки, потому что они требуют
изучения проблем координации вроде задачи византийских генералов на маштабах всей сети --
в то время как если есть централизованная инфраструктура управления, это становится проще.
Но меш-сети очень полезны в ситуациях, когда фиксированные сети недоступны или ненадежны:
например, при поисково-спасательных работах или при нарушении инфраструктуры электропитания.

Уже существуют проекты для симуляции маршрутизации в фиксированных сетях:
например, GNS3, OMNeT++~\cite{9181563} и Cisco PacketTracer.
Но с помощью таких проектов сложно сделать симуляцию беспроводной меш-сети,
особенно основанной на подвижных роботах:
эти программы ожидают, что пользователь настроит все проводные соединения
во время моделирования,
и динамическое изменение соединений в них более сложно или невозможно,
и в любом случае требует ручного ввода.

Также существуют некоторые алгоритмы для маршрутизации,
которые специализированны для меш-сетей
(например, OLSR и B.A.T.M.A.N~\cite{DBLP:journals/corr/abs-1901-02298}).
С помощью симулятора вроде нашего, можно проверять устойчивость этих алгоритмов к меняющимся условиям,
определить возможные патологические случаи
и изучать возможные улучшения
в контроллируемой среде.

\subsection{Мультиагентное планирование}

Мультиагентное планирование (MAP, \emph{Multi-Agent Planning}) --
это расширение классической задачи планирования
на множество агентов.

Обычная задача планирования состоит из двух частей:
\emph{domain} (область действия) и \emph{problem} (задача).
В domain описываются типы предметов, которые существуют,
предикаты, которые могут быть использованы в задаче,
и возможные действия (каждое из которых задается как комбинация предусловия и постусловия).

В problem описывается набор конкретных предметов,
начальное состояние мира (как множество предикатов),
а также целевое состояние -- набор предикатов, таких, что
после выполнения плана мир будет иметь данные предикаты.

Есть несколько разных определений задачи мультиагентного планирования.
Самое частое определение (согласно~\cite{doi:10.3233/MGS-2009-0133}),
которое мы используем в данном проекте, --
что в мультиагентном планировании
все агенты имеют общий domain,
а также общую информацию о начальном состоянии,
но они могут иметь разные цели.
Агенты не могут говорить друг другу о своих целях:
вместо этого они предлагают планы,
и другие агенты соглашаются или отказываются от него.

Дополнительное усложнение задачи --
когда информация о начальном состоянии не полная,
и наблюдения могут противоречить этим данным.
В таком случае агенты должны остановиться в выполнении плана
и обсудить, что делать дальше:
возможно, новая информация приведет к тому, что план нужно будет перестроить.

В контексте данной работы, меш-сеть делается для обеспечения коммуникации между роботами,
которые решают задачу мультиагентного планирования.
Хотя в общем случае модуль работы с меш-сетью можно использовать отдельно,
в данной работе мы также заинтересованы в взаимодействии этих частей:
например, робот может отказаться выполнять план,
который приведет к тому, что он окажется изолированным от других роботов.


\section{Разработка} 
\label{sec:base-section}

\subsection{Беспроводное оборудование}

Одно из первых решений, которые необходимо было принять при разработке этого проекта --
какое физическое беспроводное оборудование использовать, как модель для разработки
симулятора \footnote{Результаты разработки, включая исходный код для симулятора и для этой статьи, можно найти в интернете по адресу \texttt{https://github.com/rudn-lab/planning-mesh-swarm}.}.
В этом мы учитывали несколько факторов:

\begin{enumerate}
\item Фрейминг: задача работы с физическими (L1 и L2 по OSI-модели) фреймами уже была решена существующими протоколами передачи данных,
поэтому мы хотим использовать модуль, который дает доступ к уже готовым кадрам или пакетам, и сам занимается обработкой их из радиосигнала.
\item Обнаружение канального уровня (\emph{link-layer}): поскольку некоторые протоколы маршрутизации (например, OSPF и его улучшения~\cite{rfc5614}) требуют,
чтобы элементы сети могли понять, когда их соединение с соседом работает или нарушается,
мы хотим такое оборудование, которое уже имеет такую возможность.
(Если это не существует на уровне оборудования, то можно реализовать это виртуально,
отправляя пинг-сообщения друг другу,
но это добавляет сложность в наш код.)

\item Идентификация: чтобы в бизнес-логике не приходилось создавать и подтверждать уникальные личности для участников сети,
мы хотим, чтобы модули имели свой собственный уникальный идентификатор (например, MAC-адрес),
и передавали его автоматически с каждым сообщением:
тогда перед нами не стоит задача отличать одного отправителя от другого. 

\item Цена: у нас ограниченные материальные ресурсы для этого проекта, поэтому модули, коорые мы берем для физической реализации,
должны составлять малую долю всего бюджета.
В частности, это делает непригодными модули вроде LoRa,
хотя они были бы хорошим выбором для практических реализаций.
\end{enumerate}

По всем этим причинам мы решили использовать Wi-Fi модули ESP-01,
которые в момент написания можно купить оптом за 90 рублей штука.
Эти модули основаны на чипе ESP8266~\cite{esp8266},
который может быть использован как модуль для другого микроконтроллера
или иметь свою собственную прошивку:
это может быть полезно для выполнения hardware offloading
некоторых из процессов поддержки меш-сети.

У каждого элемента сети (например, робота)
будет несколько таких модулей.
Один модуль будет использоваться для получения сигналов,
и он будет настроен в режиме AP (точка доступа).
Остальные модули будут в режиме STA (клиент точки доступа),
и они будут подключаться к чужим AP,
чтобы передавать им сообщения.

С точки зрения модели, это значит,
что каждое соединение имеет одностороннее направление.
Для того, чтобы два устройства настроили двухстороннее общение,
каждый из них должен иметь как минимум два модуля.
На рис.~\ref{fig:connections} показана более сложная схема из 5 устройств.

Этот подход, возможно, не практичен для настоящих встраиваемых устройств,
где одной из важных целей является минимизация количества деталей
и общей потребляемой энергии;
Wi-Fi широко известен как один из самых энергоемких радио-протоколов в потребительском сегменте.
Однако эта модель полезна для симуляции,
потому что она позволяет моделировать ситуацию,
когда одно устройство может передавать сигнал другому устройству,
но не получает от него ответов.
К тому же,
можно написать драйвер для другого стиля радиомодуля,
который будет добавлять совместимость с кодом,
написанным для нашей абстракции:
для этого нужно будет только реализовать возможность создания (виртуальных)
соединений типа "один к одному",
поведение которых соответствует требованиям нашей модели.

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{connections}
  \caption{Полносвязная mesh-сеть, состоящая из пяти контроллеров Raspberry Pi Pico W, каждый из которых имеет четыре радиомодуля ESP-01 (плюс свой собственный). Каждая стрелочка обозначает одно Wi-Fi соединение. Все ESP-01, от которых выходит стрелочка одного цвета, подключены к точке доступа, которая создается контроллером, на который указывает стрелочка. Информация двигается по направлению стрелочки.}
  \label{fig:connections}
\end{figure}


\subsection{Геометрия симулятора}

Наш симулятор сделан в контексте задачи мультиагентного планирования,
и для упрощения логики планнера,
обычно такие задачи имеют дело с дискретным миром.
Кроме того, при переносе этой реализации на физических роботов,
они должны понимать,
в какой точке пространства они находятся.
Из-за этого мы приняли решение,
что роботы двигаются по квадратной сетке,
останавливаясь на пересечениях линий этой сетки.

С точки зрения логики движения, робот может свдинуться вперед или назад на целое количество клеток,
или повернуться влево-вправо на целое количество четвертей.
Это реализуется в физическом роботе посредством датчика линии,
который отслеживает, сколько линий проехал робот вперед
или на сколько четвертей он повернулся.

Радио-симуляция, напротив, не может работать в дискретных координатах,
потому что распространение радио-сигнала должно быть изотропным,
то есть симметричным относительно вращения~\footnote{Такая модель хорошо описывает антенны общего назначения,
например такие как в Wi-Fi модулях,
но бывают также более направленные антенны.
Наш симулятор может быть использован и с анизотропным профилем уровня сигнала;
для этого нужно описать форму этого профиля как функцию от XY.},
но в дискретных координатах невозможно нарисовать идеальную окружность.
Из-за этого симуляция радио-связи происходит отдельно,
и пока робот двигается от одной клетки к другой,
симулятор постоянно обновляет значение силы сигнала.
Каждый кадр, когда любой робот двигается,
состояние радио-системы будет обновляться,
и вне зависимости от того,
когда радио-модуль выполняет операцию,
он всегда получит свежую информацию.

Из-за этого логика внутри робота разделяется на две части: 
драйвер движения и драйвер радио-коммуникации.
Общение между этими модулями синхронизируется с помощью общей памяти (точнее, примитивов вроде каналов и семафоров, которые основаны на общей памяти),
а большую часть времени они работают независимо.
Это можно обеспечить на многоядерных микроконтроллерах,
таких как Raspberry Pi Pico/RP2040 (наш первый выбор для этого проекта),
или с использованием асинхронных подходов к программированию,
или это тривиально возможно с помощью поддержки множества процессов внутри ядра операционной системы вроде Linux.

\subsection{API для пользовательского кода}

Для разработки симулятора мы решили использовать язык Rust.
Он позволяет нам писать быстрый и безопасный код,
который можно компилировать на многие платформы без изменений~\cite{10.1145/2663171.2663188}.
Благодаря этому симулятор можно запускать как нативное приложение на Linux или Windows,
или как веб-приложение через WebAssembly~\footnote{Для демонстрации,
мы скомпилировали WebAssembly-версию, которую можно запустить в браузере по адресу \texttt{https://mesh-playground.roboticlab.ru/}.}.

Такое решение также позволяет использовать один и тот же код внутри симулятора
и также на реальном оборудовании --
это потребует лишь написания драйвера для этого оборудования.
По сравнению, многие существующие подходы
для симуляционных систем
используют языки,
которые нельзя портировать на embedded-платформы без изменений;
из-за этого нужно переписать код из симулятора на embedded-платформу
(что добавляет шансы добавить ошибки)
или же использовать более мощную платформу, которая способна
исполнять код на исходном языке программирования
(например, ROS2 используется для разработки роботов,
но она основана на Linux, поэтому робот должен содержать
Linux-компьютер, чтобы использовать ROS2-модули).

Этот драйвер представлен структурой, которая реализует нужный trait (это аналог интерфейса в Rust).
Для поддержки какой-то платформы нужно лишь реализовать соответствующие асинхронные~\footnote{Для embedded-разработки
на Rust используется популярный проект Embassy. С помощью него даже легче писать асинхронные программы
для embedded-платформ, чем синхронные. Это отличается от разработки на Arduino, например,
где ограничения платформы приводят к тому,
что код обычно пишется в синхронном стиле на C++.}
 методы для реализации функционала.

Для управления движением шасси мы можем сами решать, какой интерфейс обозначить,
и в данный момент (как написано раньше)
робот может сдвинуться вперед/назад на несколько клеток или сделать несколько четвертей оборотов
влево-вправо.
У него также есть возможность подождать несколько секунд,
или вывести сообщение для отладки
(оно будет видно только в симуляторе).
Этот функционал вынесен в отдельную структуру
(которую мы называем \texttt{AsyncUtils}):
эти методы фундаментальные для выбранного асинхронного движка,
потому что на разных платформах таймеры работают по-разному,
и из-за этого нельзя использовать один и тот же метод 
в симуляторе и на Embassy без изменений.
Например, на listing \ref{code:basic_movement} показано,
как выглядит простая реализация логики движения:
API выглядит примерно похожим на API для Turtle в Python,
но ограниченный на ортогональные повороты.
(Сам этот интерфейс есть на listing \ref{code:chassis}.)

\begin{listing}[h]
  \caption{Простая реализация логики движения,
  которая не общается с радио-модулем,
  а просто бесконечно двигается по квадратной спирали.}
  \label{code:basic_movement}
  \begin{minted}[fontsize=\footnotesize]{rust}
pub(crate) async fn spiral(mut chassis: impl Chassis + Send + Sync) {
    let mut side_length = 1;
    loop {
        chassis.utils().log(&format!("Spiral length is: {side_length}")).await;
        chassis.forward(side_length).await;
        chassis.turn_right().await;
        side_length += 1;
        chassis.utils().sleep(Duration::from_secs(1)).await;
    }
}
  \end{minted}
\end{listing}  

\begin{listing}[h]
  \caption{Интерфейс для шасси,
  который определяет, какие движения может произвести робот.}
  \label{code:chassis}
  \begin{minted}[fontsize=\footnotesize]{rust}
pub trait Chassis {
      async fn forward(&mut self, cells: NonZeroU8);
      async fn backward(&mut self, cells: NonZeroU8);
      async fn turn_left_quarters(&mut self, quarter_turns: NonZeroU8);
      async fn turn_right_quarters(&mut self, quarter_turns: NonZeroU8);
  
      async fn turn_left(&mut self) {
          self.turn_left_quarters(NonZeroU8::new(1).unwrap()).await
      }
  
      async fn turn_right(&mut self) {
          self.turn_right_quarters(NonZeroU8::new(1).unwrap()).await
      }
  
      async fn forward_one(&mut self) {
          self.forward(NonZeroU8::new(1).unwrap()).await
      }
  
      async fn backward_one(&mut self) {
          self.backward(NonZeroU8::new(1).unwrap()).await
      }
  
      async fn turn_left_signed(&mut self, quarters: i8) {
          if quarters > 0 {
              self.turn_left_quarters(NonZeroU8::new(quarters as u8).unwrap())
                  .await
          } else {
              self.turn_right_quarters(NonZeroU8::new(-quarters as u8).unwrap())
                  .await
          }
      }
  
      async fn turn_right_signed(&mut self, quarters: i8) {
          if quarters > 0 {
              self.turn_right_quarters(NonZeroU8::new(quarters as u8).unwrap())
                  .await
          } else {
              self.turn_left_quarters(NonZeroU8::new(-quarters as u8).unwrap())
                  .await
          }
      }
  
      fn utils(&self) -> impl AsyncUtils + Send;
  }  
  \end{minted}
\end{listing}  


Для управления радио-связью мы должны учитывать возможности физического радио-модуля.
В API доступны только те методы,
для которых у ESP-01 есть готовые AT-команды:
например, сканировать соседние Wi-Fi сети,
соединиться с одной из них,
отсоединяться
и измерять уровень сигнала.
Там также есть метод, чтобы отправить сообщение тому роботу,
с которым мы соединены,
в соответствии с моделью радио-связи, описанной выше.
Эти методы описаны в listing \ref{code:traits}.

\begin{listing}[h]
\caption{Описание интерфейса радио-приемника и передатчика.
Драйвер должен реализовать эти два интерфейса,
чтобы быть совместимым с нашим симулятором.}
\label{code:traits}
\begin{minted}[fontsize=\footnotesize]{rust}
/// Интерфейс приемника сообщений (Wi-Fi AP).
pub trait ReceiverNic<PeerId, MessageType> {
    type Error: core::fmt::Debug;
    /// Получить одно сообщение, которое было отправлено на этот приемник.
    /// У драйвера ограниченный буфер для сообщений, поэтому
    /// если это вызывается редко,
    /// то некоторые сообщения могут быть потеряны.
    ///
    /// Асинхронно блокирует, пока сообщение не получено.
    async fn get(&mut self) -> Result<(PeerId, MessageType), Self::Error>;

    /// Получает ID (например, MAC-адрес) этого приемника.
    /// Отправители будут видеть меня с этим ID.
    async fn get_id(&mut self) -> Result<PeerId, Self::Error>;
}

/// Интерфейс передатчика. Он может отправлять сообщения к одному другому приемнику,
/// но он должен сначала быть соединен с ним.
/// (Wi-Fi STA, подключенный к AP).
pub trait TransmitterNic<PeerId, MessageType> {
    type Error: core::fmt::Debug;

    /// Проверяет, что данный передатчик функционирует.
    async fn ping(&mut self) -> Result<(), Self::Error>;

    /// Получает, к какому приемнику мы подключены.
    async fn get_peer(&mut self) -> Result<Option<PeerId>, Self::Error>;

    /// Получает уровень сигнала текущего подключения.
    /// Уровень сигнала может быть 0, если мы сейчас не в области
    /// доступности приемника.
    async fn get_connection_info(&mut self) -> Result<ConnectionInfo<PeerId>, Self::Error>;

    /// Сканирует доступные приемники. Возвращает количество видимых ID.
    /// Найденные ID записываются в переданный массив.
    /// Если видно приемников меньше, чем в массиве места,
    /// то значение последних элементов не определено.
    async fn scan(&mut self, peers: &mut [PeerId]) -> Result<usize, Self::Error>;

    /// Пытается подключиться к одному приемнику.
    /// Если он в радиусе действия и подключение успешно,
    /// возвращает Ok(()).
    async fn pair(&mut self, peer: PeerId) -> Result<(), Self::Error>;

    /// Пытается отключиться от приемника.
    /// Работает даже если приемник не в радиусе действия.
    /// Если мы не подключены к приемнику, то ничего не делает.
    async fn unpair(&mut self) -> Result<(), Self::Error>;

    /// Отправляет сообщение подключенному приемнику.
    async fn send(&mut self, message: MessageType) -> Result<(), Self::Error>;
}
\end{minted}
\end{listing}

Наконец, две части управления запускаются в отдельных потоках
(с помощью инструментов движка в симуляторе
и через \texttt{\#[embassy::task]} на физической платформе).
Для координации между ними предоставлены методы,
которые позволяют им информировать друг друга о том, что произошло интересное событие
(например, логика движения хочет
отправить сообщение другому роботу,
или другой робот успешно доставил сообщение этому).

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{simulator-connections}
	\caption{Меш-сеть, представленная на рис. \ref{fig:connections}, реализованная внутри симулятора. Каждый робот имеет четыре виртуальных интерфейса, которые позволяют им установить соединение с каждым из соседей. Также на рисунке видна аура и пунктирная окружность вокруг верхнего робота, показывающая радиус действия его радио-интерфейсов; индикатор уровня сигнала, показывающий, что связь между верхним и нижним-правым роботом имеет уровень 39\%. Также видны кружочки на соединениях: это радио-сообщения, летящие между роботами, которые были отправлены, но еще не доставлены.}
  \label{fig:simulator-connections}
\end{figure}

\subsection{Ограничение памяти в микроконтроллерах}

Многие embedded-системы имеют очень маленькие лимиты оперативной
памяти и других ресурсов, особенно по сравнению с обычными компьютерами.
Например, на Raspberry Pi Pico, 
на которую мы ориентируемся в этом проекте,
есть 264KB оперативной памяти
и только 2MB flash-памяти~\cite{raspberrypi2021}.
(из которых можно использовать 1MB, если есть цель использовать OTA-обновление).

Из-за этого, при разработке интерфейсов есть приоритет --
использовать как можно меньше оперативной памяти.
Это можно увидеть в некоторых архитектурных решениях:
например, при сканировании Wi-Fi сетей,
мы не возвращаем \texttt{Vec} найденных сетей -- 
потому что тогда нужно было бы использовать динамическую память,
и можно было бы вызвать атаку \emph{Denial-of-Service},
создав очень много сетей.
Вместо этого, метод сканирования принимает указатель на буфер,
в который он сохраняет информацию о сетях:
если доступных сетей больше, чем размер буфера,
то только первые несколько сетей сохраняются в буфер,
а остальные игнорируются.

Аналогично, многие решения по архитектуре приложения
принимаются во время компиляции, а не во время выполнения.
Так, в прошивке есть фиксированное число Wi-Fi модулей,
которые может поддерживать один робот,
и после компиляции нельзя подключить к RPi Pico больше модулей.
(Меньше -- можно, потому что все операции с Wi-Fi модулем могут возвращать ошибку,
и одна из возможных ошибок -- что модуль завис или не подключен. Но проверка модулей
занимает время, которое возможно было бы лучше сэкономить.)

В случае, если этого будет не достаточно для реализации физического кода,
можно выполнить \emph{hardware offloading}:
по умолчанию мы используем модули ESP-01 как "черный ящик",
и общаемся с ними только с помощью AT-команд.
Однако процессор ESP8266 содержит 50KB оперативной памяти,
а к тому же поддерживает до 16MB программной памяти через SPI.
Можно написать особенную прошивку для этих модулей,
которая выносит некоторые аспекты работы с сетью
за пределы кода основного контроллера,
и вместо этого основной контроллер будет посылать более высокоуровневые
команды для ESP,
тем самым экономя программную память для этих более сложных операций.

Это также полезно, потому что это повышает количество ядер процессора,
которые доступны для различных операций:
в RPi Pico доступно два ядра,
и если использовать ядра ESP8266,
то всего в системе будет 6 ядер.
Они ограниченны в своих способностях для коммуникации:
если один ESP хочет передать сообщение другому,
то в наивном режиме он должен дождаться,
пока RPi не спросит его о новых событиях,
и только после этого RPi передаст это сообщение другому ESP.
Можно использовать более сложную схему, 
где разные участники шины могут отправлять сообщения друг другу
без участия центрального контроллера
(так работает шина PCI Express),
но это более сложно:
так или иначе, весь этот подход требует написания особенной прошивки
для ESP-01,
что может быть затруднительно --
наш симулятор не поддерживает такого,
и сделать поддержку -- значит фактически реализовывать виртуальную машину
для каждого типа микроконтроллеров.

Наконец, если ресурсов микроконтроллеров совсем не хватает,
то можно просто  использовать более дорогой контроллер,
например Raspberry Pi Zero:
это уже полноценный Linux-компьютер с 512MB оперативной памяти;
по сравнению с микроконтроллерами это позволит запускать
очень сложные программы.

\subsection{Архитектура симулятора}

Поскольку мы выбрали Rust как основной язык разработки,
то мы решили использовать Bevy -- игровой движок на основе модели ECS
(\emph{Entity-Component-System}).
В этой модели существуют сущности (\emph{Entity}),
которые имеют лишь уникальный идентификатор.
К ним привязаны один или несколько компонентов
(\emph{Component}), которые описывают какое-то состояние:
например, в симуляторе используются компоненты,
которые обозначают, что данная сущность является роботом,
который в данный момент двигается от одной клетки к другой.
Наконец, при работе вызываются системы (\emph{System}) --
функции, которые обрабатывают и изменяют данные
в компонентах.

Эта архитектура похожа на ту, которая используется в более популярных
игровых движках вроде Unity~\cite{unity} и Godot;
однако там компоненты и системы
объединяются в одну сущность
(в Unity эта сущность называется \texttt{MonoBehaviour}).
Этот дизайн работает хуже в ситуациях,
когда один код должен действовать над несколькими разными объектами
(например, в симуляциях радио в этом проекте)
и часто требует создания дополнительных виртуальных объектов в игровом мире
для такой координации.

Общие типы сущностей, которые представлены в ECS -- 
роботы, их радио-модули,
соединения между роботами
и сообщения в полете.

\subsection{Сущность: Робот}

Для визуализации, робот имеет \emph{Mesh2d} и \emph{ColorMaterial}:
он отображается как белый треугольник.
Он также содержит \emph{RobotProps},
которые определяют базовые характеристики робота
(такие как скорость движения и поворота),
и \emph{RobotState}: 
его текущее состояние, в том числе
положение, направление движения
и каналы коммуникации с фоновыми потоками,
которые реализуют основную логику поведения.

При создании робота в симуляторе запускается два фоновых потока:
один -- для кода шасси
и один -- для кода радио-модуля.
Это сделано так, чтобы две задачи были незавиг от друга,
чтобы можно было менять поведение шасси без изменения радио-протокола.

Робот имеет два состояния: \emph{IdleRobot} и \emph{BusyRobot};
они представлены дополнительными компонентами.
Когда робот находится в состоянии \emph{IdleRobot},
он готов начать движение
(линейное или вращение).
Когда он начинает движение,
то к нему добавляется компонент,
который выполняет анимацию движения,
а сам робот становится \emph{BusyRobot}
(потому что он не может начать новое движение,
пока он не завершит предыдущее).
Наконец, когда робот завершает движение,
то компонент анимации удаляется,
а робот возвращает в состояние \emph{IdleRobot};
параллельно с этим
в фоновый поток отправляется сообщение,
которое разрешает скрипту шасси продолжить исполнение.

\subsection{Сущность: Интерфейс}

У каждого робота по умолчанию есть приемник,
который физически представлен как Wi-Fi AP.
Однако у него также может быть переменное число передатчиков:
каждый из них будет представлен отдельной сущностью,
которая следит за положением своего робота.

Такая сущность имеет настройки:
какой радиус действия у этой антенны есть,
какого цвета показывать ауру вокруг нее,
а также -- есть ли соединение с другим роботом,
и если да, то какой сущностью это соединение представлено.

\subsection{Сущность: Сообщение}

Для симуляции сложных консенсусных протоколов
может быть полезно иметь задержку между отправкой сообщения
и получением его,
а также разрешить пользователю вручную перехватывать и удалять сообщения в полете.
Для этого, вместо того чтобы сообщения доставлялись моментально после отправки,
они получают физическую форму в виде сущности-сообщения.
Сообщения показываются на экране как фиолетовые кружочки,
которые двигаются с постоянной скоростью к своему целевому роботу.
Когда сообщение оказывается близко к роботу,
то сама сущность сообщения удаляется,
а сообщение передается в очередь,
из которой скрипт данного робота может прочитать его.

\section{Алгоритмы маршрутизации}

После создания симулятора,
поверх него можно реализовать алгоритмы маршрутизации.
Поскольку целью является использовать этот код на микроконтроллере,
нужно использовать алгоритмы, которые не будут требовать высокого
количества оперативной памяти.

Один из самых простых алгоритмов -- \emph{flooding},
где каждый элемент сети распространяет сообщение
всем своим соседям, вне зависимости от того, видели ли они это сообщение уже или нет.
Слегка более сложная схема -- \emph{controlled flooding} -- игнорирует сообщение,
если оно уже было получено небольшое время назад (для этого
используется циклический буфер)~\cite{rahman2004controlled}.
Такие алгоритмы пригодны в ситуациях,
когда нужно распространить какую-то информацию по всей сети;
например, если нужно выполнить OTA-обновление прошивки микроконтроллеров.
Однако этот алгооритм имеет недостатки,
связанные с тем, что вся сеть будет получать одно и то же сообщение,
даже если этой части сети не интересно получать такое сообщение.

Более сложные алгоритмы маршрутизации,
используемые и в проводных сетях,
чаще всего делятся на два типа:
\emph{link-state routing} и \emph{distance-vector routing}.

В link-state, каждый роутер имеет информацию про карту всей сети.
Эта карта распространяется между роутерами с помощью flooding:
сначала каждый роутер говорит своим соседям обо всех своих ближайших соседях,
а затем каждый получатель добавляет к карте информацию о своих соседях,
и таким образом постепенно выстраивается полная карта всей сети.
После этого, если какой-то роутер хочет послать информацию какому-то другому роутеру,
то он строит маршрут с помощью своей собственной карты.
Что происходит дальше -- зависит от конкретного алгоритма:
в некоторых (например, \emph{Dynamic Source Routing}, DSR), этот желаемый маршрут вкладывается в заголовок пакета,
и остальные роутеры просто направляют пакет по этому маршруту,
и если какой-то шаг маршрута становится невозможным, то пакет просто удаляется
(этот подход работает хорошо в сетях, где маршруты редко становятся неверными,
как например в проводных сетях внутри здания).
В других алгоритмах, первый роутер просто отправляет свой пакет
по тому из своих соединений, которое указано первым в своем запланированном маршруте.
Следующий роутер будет использовать свою собственную карту, чтобы построить маршрут опять -- 
такой подход требует больше вычислений,
но работает лучше в ситуациях, когда маршруты могут прерываться неожиданно,
и эта информация не сразу распространяется по сети.

Чтобы каждый роутер не должен был хранить полную карту всей сети,
используется distance-vector: другой основной подход к маршрутизации.
Каждый роутер хранит меньшее количество информации:
ему нужно иметь только вектор расстояний от себя до других роутеров в сети.
Как и в link-state, каждый роутер обменивается этой информацией со своими соседями,
и соседи обновляют свое понимание сети в зависимости от этого;
алгоритм считается завершенным, когда каждый роутер получил стабильное понимание сети
и больше не обновляет свои векторы расстояний.

Алгоритмы типа distance-vector лучше подходят для беспроводных меш-сетей,
потому что роутеры не должны хранить полную карту всей сети (что занимает много памяти).
В частности, Zigbee -- протокол, который часто используется в IoT-устройствах ввиду своего низкого
энергопотребления --
основан на \emph{Ad-hoc On-Demand Distance Vector Routing} (AODV),
который был первый раз описан в 1999 году~\cite{perkins1999aodv}
и стандартизирован в RFC 3561~\cite{rfc3561}.
В AODV роутеры обмениваются информацией только в том случае,
если у них уже нет маршрута до какого-либо узла:
это минимизирует потребление памяти,
но увеличивает задержку для первого пакета для нового узла.


\section{Заключение}

В данной работе мы разработали симулятор для беспроводных мобильных меш-сетей
и продемонстрировали его API.
На основании этого API можно реализовать алгоритмы, которые будут
работать без изменения кода на виртуальной и аппаратной платформах.
Таким образом мы привносим новизну в область моделирования сетевых архитектур,
в которой раньше большее внимание уделялось задачам моделирования фиксированных сетей.

Из-за гибкости языка Rust,
интерфейс, который мы предоставляем для пользовательского кода,
может быть использован в различных микроконтроллерах.
Благодаря этому мы можем ожидать,
что работа с нашим симулятором станет основой
для будущих меш-архитектурных решений,
поддерживающих разные микроконтроллеры
и физические радио-интерфейсы.

\subsection{Дальнейшая работа}

Наш симулятор предназначен в основном для интерактивного использования,
и он требует графического интерфейса.
Из-за этого он непригоден для ситуаций, когда GUI недоступен,
например на серверах или суперкомпьютерах.
Он также ограничен скоростью симуляции:
многие события требуют, чтобы хотя бы один кадр симуляции прошел
между действием и реакцией
(например: каждая транзакция между кодом радио-модуля
и виртуальным радио-модулем
требует одного кадра,
чтобы быть принятой симулятором.
Из-за этого,
даже если поставить скорость движения сообщений равной бесконечности,
то один робот все равно не сможет передать другому роботу
больше чем 60 сообщений в секунду.)

Эти ограничения связаны с конкретной реализацией симулятора
на основе игрового движка Bevy,
и в частности с тем, что для сообщений создаются отдельные сущности.
В будущем планируется создать опциональную реализацию,
которая будет работать без графического интерфейса
и обрабатывать события в дискретном времени:
с помощью этой версии можно будет симулировать гораздо более крупные сети.

Для использования в контексте задачи
мультиагентного планирования,
в симулятор будут добавлены
функции для создания дополнительных объектов,
с которыми могут взаимодействовать роботы:
это позволит отслеживать то,
как алгоритм маршрутизации и алгоритм планирования работают вместе.
В данный момент роботы могут только двигаться без ограничений,
и для более интересной задачи нужно будет добавить стены, которые препятствуют движению роботов,
радио-сигналов, или обоих.

Также следует добавить в симулятор
возможность менять код роботов во время исполнения:
в данный момент все роботы выполняют один и тот же скрипт.
Также следует добавить возможность добавлять свой собственный код:
в данный момент код роботов компилируется вместе с кодом симулятора,
и его нельзя изменить без перекомпиляции всего проекта.

Это можно сделать, например,
внедрив в симулятор виртуальную машину,
которая исполняет код для какой-то конкретной платформы,
и затем компилировать скрипт для робота для этой платформы.
Это может быть WebAssembly,
или (для симуляции ограниченных ресурсов)
это может быть виртуальная машина для какой-то RISC-архитектуры:
например, так работает компьютерная игра \emph{kartoffels}~\cite{kartoffels}.

Наконец, для того, чтобы можно было оценивать качество алгоритма
количественно, а не только качественно,
можно добавить в симулятор
сущности,
которые создают сообщения
и которые поглощают их
(так называемые \emph{source} или \emph{sink}).
Они могут измерять количество сообщений,
вошедших в сеть,
и количество успешно доставленных сообщений.

Для этого также нужно добавить возможность сохранять расположение роботов
в файл и загружать симуляцию из него:
тогда можно будет проводить эксперименты
над задачами.
Эти задачи могут быть стандартизированными,
чтобы разные алгоритмы можно было сравнивать друг с другом
в идентичных условиях.


%Заключение является неотъемлемой частью любой работы. 

%Оно должно содержать краткие выводы по результатам исследования,
%отражающие новизну и практическую значимость работы, предложения по
%использованию ее результатов, оценку её эффективности и качества.

% \section{Ethical disclaimers}

% A disclaimer is a note of disclaimer of responsibility~\cite{kulyabov_2024_editorial_author-ethics_en}.
% For example, authors' statements about conflicts of interest, author contributions, acknowledgements, etc.

% Authors should not prepare these disclaimers as a numbered or unnumbered
% \mintinline{latex}{\section}%
% ; please use the special environments instead.

% \subsection{Author contributions}

% The Committee on Publication Ethics (COPE) draws attention to the problem of authorship \cite{cope_book_authorship_en}.
% The CRediT system (\url{https://credit.niso.org/}) is proposed to formalize author roles.
% The CRediT (Contributor Roles Taxonomy) offers 14 possible author roles \cite{holcombe_2019_contributorship-not-authorship_en}.
% This is not really a taxonomy, but a faceted classification. Author roles are not always independent in themselves.

% The following statements should be used \emph{Conceptualization, X.X. and Y.Y.; methodology, X.X.; software, X.X.; validation, X.X., Y.Y. and Z.Z.; formal analysis, X.X.; investigation, X.X.; resources, X.X.; data curation, X.X.; writing---original draft preparation, X.X.; writing---review and editing, X.X.; visualization, X.X.; supervision, X.X.; project administration, X.X.; funding acquisition, Y.Y.}
% Please add at the end of the statement:
% \emph{All authors have read and agreed to the published version of the manuscript.}

% This section has a special environment:
% \begin{minted}{latex}
% \begin{authorcontributions}
% …
% \end{authorcontributions}
% \end{minted}

% \subsection{Funding}

% Disclaimer \emph{funding} refers primarily to external funding if the research was externally initiated.
% If the research is entirely the initiative of the author's team, it is better to indicate gratitude for partial funding of some of the stages of the research in the \emph{Acknowledgments} section.
% The fact that the author's team has received external funding should be recorded in the disclaimer as a matter of course.
% When mentioning the sponsor, its exact data (name of the organization, grant number, etc.) and the country of its location should be specified (for example \emph{This research was funded by NAME OF FUNDER grant number XXX}).
% If there is any support, it is recommended to clarify in the \emph{Conflicts of interest} section at which stages of the research and how the support was used.
% If there is no external funding, it is written: \emph{This research received no external funding}.
% If it is impossible to obtain information from the authors about the source of funding, then write: \emph{Not specified}.

% This section has a special environment:
% \begin{minted}{latex}
% \begin{funding}
% …
% \end{funding}
% \end{minted}

% \subsection{Data availability statement}

% Data are particularly important in reproducible researches.
% The data availability statement tells the reader where the research data related to the article are located and under what conditions the data can be accessed.
% References to the dataset are also provided.

% If no new data is created or analyzed, please write:
% \emph{No new data were created or analyzed in this study. Data sharing is not applicable.}

% This section has a special environment:
% \begin{minted}{latex}
% \begin{dataavailability}
% …
% \end{dataavailability}
% \end{minted}

% \subsection{Conflicts of interest}

% This disclaimer must be included.

% Conflicts of interest can comment on various aspects, but usually the author's past or current employment is indicated.
% Grants (especially from for-profit companies) received not only by the author but also by the organization for which he or she works are indicated.
% If the author is associated with a sponsor, it is indicated where the research was conducted.

% If there is no conflict of interest, then the corresponding statement should also be included: \emph{The authors declare no conflict of interest}.

% This section has a special environment:
% \begin{minted}{latex}
% \begin{conflictsofinterest}
% …
% \end{conflictsofinterest}
% \end{minted}

% \subsection{Acknowledgments}

% Identification of funding sources and other support, and thanks to individuals and groups that assisted in the research and the preparation of the work should be included in an acknowledgment section, which is placed just before the reference section in your document.

% This section has a special environment:
% \begin{minted}{latex}
% \begin{acknowledgments}
% These are different acknowledgments.
% \end{acknowledgments}
% \end{minted}
% so that the information contained therein can be more easily collected during the article metadata extraction phase, and to ensure consistency in the spelling of the section heading.

% \section{Appendices}

% If your work needs an appendix, add it before the
% \mintinline{latex}{\end{document}}
% command at the conclusion of your source document.

% Start the appendix with the
% \mintinline{latex}{\appendix}
% command:
% \begin{minted}{latex}
% \appendix
% \end{minted}
% and note that in the appendix, sections are lettered, not numbered.

\vspace{\baselineskip}

% \begin{authorcontributions}
% %  Концептуализация, написание --- рецензирование и редактирование: Анна Владиславовна Королькова; методология, написание --- подготовка первоначального варианта: Дмитрий Сергеевич Кулябов.
% Концептуализация, написание --- подготовка первоначального варианта: Генералов Даниил Михайлович;
% руководство, написание --- рецензирование и редактирование: Андрей Николаевич Виноградов.
%   Все авторы прочитали и согласились с опубликованной версией рукописи.
% \end{authorcontributions}

% \begin{funding}
%   Данное исследование не получало внешнего финансирования.
% \end{funding}

% \begin{dataavailability}
%   В ходе исследования не было создано и проанализировано никаких новых данных. Совместное использование данных неприменимо.
% \end{dataavailability}

% \begin{conflictsofinterest}
%   Авторы заявляют об отсутствии конфликта интересов.
% \end{conflictsofinterest}

%\begin{acknowledgments}
%  Мы благодарим организаторов конференции за предоставленную возможность создать этот шаблон.
%\end{acknowledgments}

%%
%% Define the bibliography file to be used

% \printbibliography

\section{Список литературы}

\printbibliography[heading=none]

%%
%% If your work has an appendix, this is the place to put it.
%\appendix

%\section{Онлайн-ресурсы}

%\begin{itemize}
%\item Overleaf: \url{https://www.overleaf.com/read/vjvjpsqrqjhj#86e97e}.
%\item Overleaf (russian): \url{https://www.overleaf.com/read/yjmkpnvgqzdk#bf8ccf}.
%\end{itemize}

\end{document}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: t
%%% End:



@article{DBLP:journals/corr/abs-1901-02298,
  author       = {Benjamin Sliwa and
                  Stefan Falten and
                  Christian Wietfeld},
  title        = {Performance Evaluation and Optimization of {B.A.T.M.A.N.} {V} Routing
                  for Aerial and Ground-based Mobile Ad-hoc Networks},
  journal      = {CoRR},
  volume       = {abs/1901.02298},
  year         = {2019},
  url          = {http://arxiv.org/abs/1901.02298},
  eprinttype    = {arXiv},
  eprint       = {1901.02298},
%  timestamp    = {Thu, 31 Jan 2019 13:52:49 +0100},
%  biburl       = {https://dblp.org/rec/journals/corr/abs-1901-02298.bib},
%  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@misc{rfc5614,
    series =    {Request for Comments},
    number =    5614,
    howpublished =  {RFC 5614},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC5614},
    url =       {https://www.rfc-editor.org/info/rfc5614},
    author =    {Richard Ogier and Phil Spagnolo},
    title =     {{Mobile Ad Hoc Network (MANET) Extension of OSPF Using Connected Dominating Set (CDS) Flooding}},
    pagetotal = 71,
    year =      2009,
    month =     aug,
    abstract =  {This document specifies an extension of OSPFv3 to support mobile ad hoc networks (MANETs). The extension, called OSPF-MDR, is designed as a new OSPF interface type for MANETs. OSPF-MDR is based on the selection of a subset of MANET routers, consisting of MANET Designated Routers (MDRs) and Backup MDRs. The MDRs form a connected dominating set (CDS), and the MDRs and Backup MDRs together form a biconnected CDS for robustness. This CDS is exploited in two ways. First, to reduce flooding overhead, an optimized flooding procedure is used in which only (Backup) MDRs flood new link state advertisements (LSAs) back out the receiving interface; reliable flooding is ensured by retransmitting LSAs along adjacencies. Second, adjacencies are formed only between (Backup) MDRs and a subset of their neighbors, allowing for much better scaling in dense networks. The CDS is constructed using 2-hop neighbor information provided in a Hello protocol extension. The Hello protocol is further optimized by allowing differential Hellos that report only changes in neighbor states. Options are specified for originating router-LSAs that provide full or partial topology information, allowing overhead to be reduced by advertising less topology information. This memo defines an Experimental Protocol for the Internet community.},
}

@ARTICLE{9181563,
  author={Bautista, Pablo Andrés Barbecho and Urquiza-Aguiar, Luis Felipe and Cárdenas, Leticia Lemus and Igartua, Mónica Aguilar},
  journal={IEEE Access}, 
  title={Large-Scale Simulations Manager Tool for OMNeT++: Expediting Simulations and Post-Processing Analysis}, 
  year={2020},
  volume={8},
  number={},
  pages={159291-159306},
  keywords={Tools;Analytical models;Data models;Python;Adaptation models;Computational modeling;Writing;Large-scale simulations;OMNeT++;results post-processing},
  doi={10.1109/ACCESS.2020.3020745}}


@article{doi:10.3233/MGS-2009-0133,
author = {Mathijs de Weerdt and Brad Clement},
title ={Introduction to planning in multiagent systems},
journal = {Multiagent and Grid Systems},
volume = {5},
number = {4},
pages = {345-355},
year = {2009},
doi = {10.3233/MGS-2009-0133},
URL = {https://journals.sagepub.com/doi/abs/10.3233/MGS-2009-0133},
eprint = {https://journals.sagepub.com/doi/pdf/10.3233/MGS-2009-0133},
abstract = {
In most multiagent systems planning on forehand can help to seriously improve the efficiency of executing actions. The main difference between centrally creating a plan and constructing a plan for a system of agents lies in the fact that in the latter coordination plays the main part. This introduces a number of additional difficulties. This special issue discusses some of these difficulties in detail. To place these in a context, this introduction gives a brief overview of multiagent planning problems, and most multiagent planning techniques.
}
}

@manual{esp8266,
organization = "Espressif Systems",
title = "32-bit MCU-based SoC with integrated 2.4GHz Wi-Fi transciever",
number = "ESP8266EX",
year = 2023,
note = "Version 7.0"
}

@article{10.1145/2692956.2663188,
author = {Matsakis, Nicholas D. and Klock, Felix S.},
title = {The rust language},
year = {2014},
issue_date = {December 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {3},
issn = {1094-3641},
url = {https://doi.org/10.1145/2692956.2663188},
doi = {10.1145/2692956.2663188},
abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety.Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
journal = {Ada Lett.},
month = oct,
pages = {103–104},
numpages = {2},
keywords = {affine type systems, memory management, rust, systems programming}
}

@inproceedings{10.1145/2663171.2663188,
author = {Matsakis, Nicholas D. and Klock, Felix S.},
title = {The rust language},
year = {2014},
isbn = {9781450332170},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2663171.2663188},
doi = {10.1145/2663171.2663188},
abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety.Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
booktitle = {Proceedings of the 2014 ACM SIGAda Annual Conference on High Integrity Language Technology},
pages = {103–104},
numpages = {2},
keywords = {affine type systems, memory management, rust, systems programming},
location = {Portland, Oregon, USA},
series = {HILT '14}
}

@software{unity,
  author = {{Unity Technologies}},
  title = {Unity},
  version = {2023.2.3},
  year = {2023},
  url = {https://unity.com/},
  note = {Game development platform},
}



%%% Local Variables:
%%% mode: bibtex
%%% coding: utf-8-unix
%%% End:

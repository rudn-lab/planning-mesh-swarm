\chapter{Одноагентный планировщик}

Проведённый обзор существующих методов кооперации и разрешения конфликтов
в мультиагентных системах позволил выявить ключевые направления развития,
а также ограничения и пробелы в текущих подходах.
На основе полученных результатов была сформулирована архитектурная
концепция собственной системы планирования.
Следующим этапом стала разработка и реализация планировщика для одного агента,
который служит фундаментом для построения более сложной мультиагентной системы.
Этот компонент необходим не только для отладки и верификации базовых алгоритмов,
но и для обеспечения гибкости и расширяемости
при переходе к взаимодействию между несколькими агентами.
В данной главе подробно рассматривается внутренняя
структура одноагентного планировщика и принципы его функционирования\footnotemark{}.

\footnotetext{
  Результаты разработки, включая исходный код планировщика и этой статьи,
  можно найти в интернете по адресу \url{https://github.com/rudn-lab/planning-mesh-swarm/}
}

\section{Цели при разработке планировщика}

Основная причина, по которой нельзя использовать уже существующий планировщик,
заключается в том, что нам необходима гибкость и контроль над внутренней структурой,
что может быть обеспечено только своим планировщиком. Таким образом,
не будет ограничений, связанных с существующей программной архитектурой.
Цели при разработке этого планировщика были следующими:

\begin{enumerate}
  \item Гибкость --- изменения в отдельных компонентах
    должны быть легко реализуемы в процессе разработки для облегчения
    экспериментов и предотвращения возможных переписей в будущем, если текущая
    структура помешает дальнейшему развитию.
  \item Корректность --- весь код планировщика должен быть покрыт
    модульными и интеграционными тестами.
    Из-за этого быть уверенными в поведении каждого компонента,
    а также в корректности всего планировщика.
    Это также предотвратит ошибки в процессе разработки и регрессии при рефакторинге.
  \item Скорость --- планировщик должен быть достаточно быстрым для решения предоставленных задач.
  \item Расширяемость --- \jar{Application Programming Interface} (API)
    этого планировщика в виде библиотеки должен позволять потенциальному программисту
    легко определять собственные алгоритмы планирования.
\end{enumerate}

К концу разработки планировщика нам удалось успешно
достигнуть всех перечисленных целей.

\section{Выбор языка программирования}

Планировщик в этой работе был написан на языке программирования Rust~\cite{rust},
так как он обладает несколькими преимуществами по сравнению с более популярными языками,
такими как C++, Java, Python и C\#,
что делает его языком выбора для написания стабильных
и высокопроизводительных приложений. Вот эти преимущества:

\begin{itemize}
  \item \textbf{Безопасность памяти} --- система проверки заимствований в Rust гарантирует,
    что выделение и освобождение памяти всегда происходит безопасно,
    что устраняет целые классы ошибок, такие как <<двойное освобождение>>
    и <<использование после освобождения>>.
    Система проверки заимствований устраняет необходимость в сборщике мусора,
    что дополнительно увеличивает производительность и позволяет библиотекам,
    написанным на Rust, использоваться не только другими программами на Rust,
    но и программами на других языках через интерфейс внешних функций
    (\jar{Foreign function interface}, FFI).
  \item \textbf{Явная изменяемость} --- система проверки заимствований
    также контролирует способ доступа к переменным в Rust.
    Данные либо не изменяемы по умолчанию, что означает, что они не могут быть изменены и,
    следовательно, могут быть заимствованы многими функциями,
    либо они явно изменяемы, что позволяет модификации,
    но ограничивает количество заимствующих до одного.
    Это гарантирует, что данные всегда остаются консистентными,
    устраняет условия гонки и обеспечивает требуемые паттерны использования.
  \item \textbf{Низкоуровневый контроль} --- используя ключевое слово \textit{unsafe},
    Rust позволяет выполнять низкоуровневые операции,
    выходящие за пределы контроля системы заимствований,
    такие как арифметика указателей.
    Однако, случаи, когда такой низкоуровневый доступ необходим --- довольно редки.
  \item \textbf{Сильная типизация} --- алгебраическая система типов Rust
    позволяет выражать структуры данных наиболее естественным способом,
    что помогает точно определять сложные состояния приложения.
    Дополнительно, \jar{типажы} (\textit{Traits}) и \jar{обобщения} (\textit{Generics})
    помогают определять общие поведения для нескольких типов,
    что позволяет реализовать сложный полиморфизм без потери производительности.
  \item \textbf{Высокая производительность} --- Rust компилируется напрямую в машинный код,
    избегая виртуальных машин, используемых в таких языках, как Java,
    что позволяет достигать уровней производительности, сравнимых с C и C++.
  \item \textbf{Эргономичность} --- хотя Rust позволяет явным образом контролировать
    многие низкоуровневые процессы, он также имеет множество высокоуровневых абстракций,
    которые упрощают процесс написания кода.
    Еще лучше то, что многие из этих абстракций являются \jar{абстракциями без дополнительных затрат},
    поэтому они не влияют на производительность программы,
    при этом немного увеличивая время компиляции.
  \item \textbf{Экосистема Crates} --- большое и увлеченное сообщество Rust
    разработало множество качественных библиотек или \jar{Crates},
    решающих многие распространенные и не очень задачи.
  \item \textbf{Встраиваемые приложения} --- программу на Rust легко разрабатывать для встраиваемых систем.
    На самом деле, этот планировщик разработан так,
    чтобы его можно было запустить на микроконтроллере,
    что повлияло на несколько решений в процессе разработки,
    например, на необходимость интернирования~\cite{enwiki:interning} всех строк, используемых для имен.
\end{itemize}

Все эти факторы, а также высокая степень знакомства авторов с этим языком,
сделали Rust очевидным выбором для разработки планировщика.

\section{Архитектура}

Архитектура планировщика довольно проста.
Два центральных компонента — это Состояние и Действие.
Хотя Домен и Задача являются тем, что планировщик потребляет,
именно эти два компонента играют основную роль в процессе планирования.

\pc{Состояние} представляет собой всю текущую информацию о мире
в виде набора \pc{Предикатов}, которые похожи на вопросы,
на который можно ответить <<да>> или <<нет>>:
<<Находится ли коробка $b$ в местоположении $l$?>>,
<<Находится ли робот $r$ в местоположении $l$?>>,
<<Держит ли робот $r$ коробку $b$?>> и так далее\footnotemark{}.
Если состояние содержит предикат с заданными (\textit{инстанцированными}) значениями,
то этот предикат считается \textit{истинным}, но \textit{ложным} в противном случае.
Хотя строго говоря только начальное Состояние
является явно определенным пользователем,
состояния, полученные на основе начального состояния, позволяют
планировщику оценивать выражения,
включая Цель, для нахождения решения заданной Задачи.

\footnotetext{
  Возможно, было бы правильнее сказать, что Предикат
  является центральным элементом всего планировщика, поскольку он является основой
  логики планировщика. Однако они почти никогда не
  встречаются сами по себе,
  за исключением части \cd{:init} файла задачи.
  Они всегда являются частями чего-то большего, и это <<что-то большее>> является тем,
  что пользователь создает (Действия, Выражения),
  например, при использовании этой библиотеки планирования.
}

\pc{Действие} определяет преобразование Состояния мира.
Обычно это представляет собой реальное действие,
которое, например, может выполнить робот.
Оно состоит из трех компонентов:
\begin{itemize}
  \item \pc{Параметры} --- как параметры функции в языке программирования,
    они определяют, на какие Объекты действует Действие.
    Эти параметры имеют Тип, который ограничивает Объекты.
    Они связывают Предусловие и Эффект Действия.
  \item \pc{Предусловие} --- это логическое выражение, которое комбинирует
    несколько Предикатов. Если оно оценивается как \textit{истинное} в текущем Состоянии,
    то это Действие может быть применено.
  \item \pc{Эффект} --- если Действие может быть примененно к Состоянию
    с конкретными Объектами, то этот Эффект может быть
    использован для его изменения с целью перехода в новое Состояние.
\end{itemize}

\subsection{Объекты и типы}

\pc{Объект} представляет собой отображение конкретного объекта
из реального мира в упрощенное представление в Домене.
Объекты обычно делятся на две категории: Константы и обычные Объекты.
Первые присутствуют во всех Задачах для конкретного Домена,
где они определены. На практике это означает, что Константы
могут быть использованы в определении Действия или Цели.
Обычные Объекты, с другой стороны, определяются только для конкретной Задачи.
Обе категории не могут быть изменены в процессе решения, поэтому в этом планировщике
и Константы, и Объекты
объявляются, используются, хранятся и представляются одинаково.

\pc{Типы} используются для ограничения того,
какие Объекты могут быть параметрами Действия или Предиката.
Типы позволяют объявлять в Домене как общие, так и специфичные Действия и Предикаты.
Типы образуют иерархию, в верхней части которой находится тип \textit{object}.
Когда Действие или Предикат определены с конкретным Типом,
Объекты этого Типа, а также его подтипы могут быть использованы в этих конструкциях.

И Объекты, и Типы хранятся вместе в \cd{EntityStorage},
а код вне его использует \jar{дескрипторы} --- \cd{SmartHandle}.
\cd{SmartHandle} позволяет более эффективно использовать память,
так как она хранят индекс в \cd{EntityStorage}.
Дополнительно каждый \cd{SmartHandle} хранит ссылку на сам \cd{EntityStorage}.
это помогает избежать передачи \cd{EntityStorage} в каждую функцию,
где делаются запросы к системе типов.
Паттерн \jar{Interior mutability}~\cite{interiormut} в Rust,
а также стратегическое предоставление только подмножества методов,
которые есть у \cd{EntityStorage}, позволяет гарантировать,
что все дескрипторы имеют актуальную ссылку на \cd{EntityStorage},
и что его содержимое может быть изменено только во время инициализации Домена и Задачи,
а не в процессе планирования.
Такой, возможно, несколько запутанный способ хранения позволяет
эффективно запрашивать информацию о доступных Типах и Объектах,
например, получать все \cd{ObjectHandles} для конкретного \cd{TypeHandle}.

\subsection{Предикаты}

Как уже упоминалось, \pc{Предикат} похож на вопрос с ответом <<да>> или <<нет>>.
Точнее, они могут быть либо \textit{истинными}, либо \textit{ложными} в любой момент плана.
Истинность зависит от того, находится ли Предикат в Состоянии,
если да --- то он является \textit{истинным},
и, если не указано иное, предполагается, что они ложны
(за исключением случаев, когда в качестве Требования включена гипотеза об <<открытом мире>>~\cite{marks1990planning,Keet2013}).
Предикаты применяются к конкретному типу Oбъектов или ко всем Oбъектам,
что определяется Типом аргумента, который они принимают.

Структура \cd{Predicate} в планировщике тесно соответствует этому определению.
Кроме интернированного имени предиката,
она содержит список, который указывает Типы
аргументов, которые может принимать этот Предикат.
Другой список представляет фактические значения для этих аргументов.
Значения обобщены по типу \cd{PredicateValue} (предикатное значение),
что позволяет представлять различные варианты предикатов в процессе планирования\footnotemark{}.
В этой программе используются следующие варианты \cd{Predicate}:

{\sloppy
\begin{itemize}
  \item \cd{LiftedPredicate} --- эти предикаты наиболее универсальны
    из всех. Они используются внутри определения Действия,
    и, следовательно, могут содержать весь спектр значений:
    \begin{itemize}
      \item Константы --- как уже упоминалось,
        это \cd{Objects}, которые определены в Домене
        и присутствуют для всех Задач.
      \item Параметры Действия --- Объекты, которыми оперирует Действие.
      \item Связанные переменные --- поскольку планнер поддерживает выражения
        с кванторами, нам нужно представлять переменные,
        которые связывают кванторы в предикатах.
    \end{itemize}
  \item \cd{ScopedPredicate} --- эти предикаты появляются в Цели
    и отличаются от \cd{LiftedPredicates} исключением параметров Действий.
  \item \cd{GroundPredicate} --- наиболее ограниченный тип \cd{PredicateValue}.
    Эти предикаты содержат только Объекты и представляют конкретный факт о мире планирования,
    и, как таковые, появляются только в Состоянии.
\end{itemize}
}

\footnotetext{
  Поскольку предикаты обобщены по типу значения,
  это заставляет выражения, содержащие их, также быть обобщенными по этому типу значения.
  Однако более интуитивно правильным способом представления выражений является
  представление их как обобщенных по варианту самого Предиката.
  Поэтому был реализован дополнительный типаж \cd{IsPredicate}
  для предикатов с различными значениями, чтобы достичь этого.
}

В дополнение к обязательным имени, списку аргументов и списку значений,
определение \cd{Predicate} содержит два дополнительных поля,
которые не являются частью определения предиката как такового,
но которые полезны внутри этого планировщика.
\cd{EvaluationStrategy} определяет способ оценки
любого данного предиката в Состоянии.
Когда используется стратегия \cd{Equality}, то проверяется буквальное равенство
двух значений этого предиката.
Иначе, в стратегии \cd{State} проверяется, существует ли совместимый \cd{GroundPredicate} в \cd{State}.
Другим важным полем, которое присутствует на протяжении всего процесса планирования,
но остается в основном скрытым, является уникальный \cd{Marker},
который каждый предикат генерирует при создании.
Его цель --- избежать ошибочного учета или возвращения дублирующих
предикатов после преобразования логических выражений.
Например, выражение $p \veebar q$, где $p$ и $q$ --- это какие-то предикаты,
можно преобразовать в следующее выражение в \jar{Дизъюнктивной нормальной форме} (ДНФ):
$\left(p \land \lnot q\right) \lor \left(\lnot p \land q\right)$.
В этой ДНФ и $p$, и $q$ появляются дважды,
но повторения по-прежнему представляют один и тот же предикат.
Таким образом, и исходное выражение, и полученная ДНФ должны трактоваться
как содержащие только два предиката, например, для целей
построения таблицы истинности.

Из-за относительно высокой внутренней сложности
\cd{Predicate} не создается с использованием
инстанцирования или метода построения.
Вместо этого используется паттерн
\jar{Строитель} (Builder)~\cite{enwiki:builder},
точнее, паттерн \jar{Строитель с типовым состоянием} (Typestate builder).
Он использует маркерные типы для отслеживания конфигурации строителя во время компиляции,
обеспечивая корректность.
В отличие от традиционных строителей,
которые часто позволяют создать недействительные или неполные конфигурации
поскольку все методы доступны в любой момент,
Строители с типовым состоянием предотвращают это, кодируя
текущее состояние (шаг) строителя в его типе,
так что возможны только корректные цепочки методов.
Это предотвращает создание неполных объектов
и ловит ошибки конфигурации на этапе компиляции.

В случае с \cd{Predicate} строитель довольно прост,
по сравнению с описанным ниже,
но он все же заслуживает более тщательного рассмотрения, чтобы предоставить базовую реализацию.
\cd{PredicateBuilder} является обобщенным и имеет четыре состояния,
представленные \jar{нульразмерными структурами} (zero-sized structs):
\cd{New}, \cd{HasName}, \cd{HasArguments} и \cd{HasValues},
которые используются вместо обобщенного параметра.
Эти состояния представляют основные этапы создания предиката.
Первые три этапа:
\begin{enumerate}
  \item присвоение имени,
  \item определение типов аргументов и их порядка,
  \item присвоение значений аргументам.
\end{enumerate}

Последний этап раскрывает только один метод \cd{build()},
задача которого заключается в том, чтобы проверить, что значения
могут быть корректно присвоены аргументам, а затем построить сам \cd{Predicate}.
Этот метод может вернуть ошибку, если значения не соответствуют аргументам.
Примечательно, что строитель не уничтожается при присвоении значений аргументам,
вместо этого он клонируется. Это позволяет нам использовать одно и то же определение предиката
для создания нескольких предикатов с различными наборами значений.
Чтобы упростить будущий код, \cd{PredicateBuilder}, который уже имеет
аргументы, но не значения, именуется как \cd{PredicateDefinition}.

В дополнение к полной цепочке, необходимой для определения произвольного Предиката,
этот строитель предоставляет метод, который используется для создания предикатов равенства.
Он просто принимает два значения, которые должны быть сравнены,
и создает с ними \cd{Предикат}, при этом гарантируя, что
\cd{Equality} будет выбрана как \cd{EvaluationStrategy}.

\subsection{Выражения логики первого порядка}

Предикаты могут быть объединены для формирования логических выражений или \pc{Формул}.
Этот Планировщик в частности и PDDL в целом поддерживают кванторы, такие как
квантор всеобщности и существования, в выражениях,
что означает, что эти выражения представленны логикой первого порядка.
Это представляет собой ряд уникальных проблем,
поскольку нам необходимо преобразовать свободное выражение
в такую форму, с которой можно эффективно работать для рассуждений.

\subsubsection{Кванторы}

В задаче планирования \pc{Квантор} указывает,
сколько предикатов в Домене удовлетворяют открытой формуле.
\jar{Квантор всеобщности} $\forall x P(x)$ выражает,
что для каждого $x$ в Домене предикат $P$ истин,
тогда как \jar{квантор существования} $\exists x P(x)$ означает,
что существует некоторый $x$, для которого $P$ является истинным.

Для представления его в планировщике,
структура \cd{Quantifier} содержит список всех \cd{BoundVariables},
а также выражение, в котором используются эти переменные.
Каждая \cd{BoundVariable} содержит \cd{TypeHandle} и \cd{Marker},
который, в отличие от его использования в \cd{Predicate},
здесь указывает, с каким \cd{Quantifier} связана переменная;
поэтому он создается уникально для каждого \cd{Quantifier},
но может быть одинаковым для \cd{BoundVariables}.
Структура \cd{Quantifier} является обобщенной по нульразмерной структуре,
который указывает на его тип.

Для создания \cd{Quantifier} используется еще один строитель с типовым состоянием с двумя этапами.
На первом этапе задаются типы переменных,
а также выбирается тип конструируемого квантора,
предоставляя выбор между двумя методами,
которые устанавливают обобщенный параметр для самого строителя.
На втором этапе принимается \jar{замыкание} (closure), которое принимает связанные переменные
и возвращает выражение или, возможно, ошибку создания, которая унаследована при создании \cd{Predicate}.
Стоит уделить этому паттерну немного больше внимания, так как он будет часть повторяться в дальнейшем.

Задание внутреннего выражения таким образом решает несколько задач одновременно:
\begin{enumerate}
  \item Это предоставляет удобный способ использования связанных переменных в связанном выражении.
    Замыкание с \cd{BoundVariables} в качестве единственного параметра
    обеспечивает удобный доступ к ним. Код, вызывающий строителя, не должен
    как-то извлекать переменные, и тем самым нарушать эргономику.
    Вместо этого они предоставляются естественным образом.
    Это также делает неиспользование их осознанным выбором со стороны вызывающего кода,
    так как компилятор предупредит его о неиспользуемых переменных, что нужно явно игнорировать.
  \item Это задерживает построение связанного выражения.
    Не стоит строить связанное выражение сразу же
    перед передачей его в квантор, так как это не только противоречит идее использования строителя,
    который легко позволяет задерживать создание, но также может быть просто неудобно делать это сразу.
  \item Это облегчает управление ошибками.
    Создание всех объектов во время финализации строителя
    позволяет выполнять все необходимые проверки корректности в одном месте.
    Это также упрощает код, поскольку тогда только метод \cd{build()} может возвращать ошибки.
  \item Это упрощает написание кода.
    Когда используется этот паттерн, код становится проще как для написания, так и для понимания,
    что станет более понятно для более сложного строителя, например, для парсера позже.
\end{enumerate}

Во время выполнения функции \cd{build()},
\cd{TypeHandles} преобразуются в \cd{BoundVariables},
и замыкание, которое создает выражение, вызывается с ними в качестве параметров.
Поскольку связанное выражение создает Предикаты,
этот метод также может возвращать ошибки,
которые унаследованы от \cd{PredicateBuilder} или возникли во время
парсинга или при определении Домена или Задачи.

\subsubsection{Выражения}

Основным типом, который определяет выражение в коде планировщика,
является перечисление \cd{QuantifiedFormula}.
С помощью его вариантов рекурсивно поддерживаются общие логические соединители,
такие как \textit{И}, \textit{ИЛИ} и \textit{НЕ};
кванторы, используя отдельное перечисление
для кванторов всеобщности и существования;
и простой Предикат, который служит самым нижним элементом в дереве выражений.
Другие логические соединители, которые не определены явно
как варианты этого перечисления, могут быть построены с помощью
конструкторских методов, которые преобразуют их в определенные варианты.
Например, импликацию можно просто выразить с помощью основных вариантов.

Тем не менее, такое выражение невозможно эффективно обрабатывать из-за его сложности.
Хотя оно позволяет нам выразить необходимое состояние мира для использования действия
или цели планировщика, с ним существуют две проблемы:

\begin{enumerate}
  \item Кванторы перемешаны внутри выражения.
    Это затрудняет как его оценку, так и
    проверку того, какие значения должны быть подставлены в Предикаты
    при решении Задачи.
  \item Несоответствие формата.
    Наличие столь множества возможных соединителей
    позволяет выражению быть определенным с произвольной
    глубиной и шириной, что делает его сложным для быстрой оценки.
\end{enumerate}

Итак, первый шаг, даже перед тем, как такие выражения можно использовать
в планировщике, -- преобразовать их в нечто,
что имеет предсказуемую структуру и
легко обрабатывается.

Чтобы упростить работу с кванторами,
выражение преобразуется в \jar{Предваренную нормальную форму} (ПНФ),
в котором все кванторы находятся в \jar{префиксе} перед выражением,
а оставшаяся часть --- \jar{матрица} --- не содержит кванторов.
Это обычно трехступенчатый процесс:

\begin{enumerate}
  \item Преобразовать формулу в \jar{Нормальную форму отрицания} (НФО);
  \item Переименовать все связанные переменные,
    чтобы имена были уникальными для всех кванторов;
  \item Переместить все кванторы перед выражением.
\end{enumerate}

Однако из-за того, как определены и используются \cd{BoundVariables},
можно пропустить второй шаг
и сразу перейти к перемещению кванторов на передний план после преобразования формулы в НФО.

На первом шаге формула изменяется таким образом,
что отрицания либо исчезают, либо применяются исключительно к предикатам.
Это достигается с помощью рекурсивной формулы,
которая применяет \jar{Законы де Моргана}, чтобы переместить отрицания внутрь.
Результирующий НФО в планировщике представлен отдельным перечислением,
которое почти полностью соответствует \cd{QuantifiedExpression}, но не содержит
вариант \cd{Not} и не имеет отдельного варианта \cd{Predicate}.
Вместо этого оно содержит дополнительное перечисление \cd{Primitives},
которое представляет либо \cd{Predicate}, как есть, либо его негативную версию.
Использование этой дополнительной структуры данных утверждает на этапе компиляции,
что выражение действительно находится в НФО.

Второй шаг преобразует этот НФО в настоящий ПНФ.
Обычно это делается синтаксически,
путем применения конкретных правил эквивалентности,
например, $\left(\forall x \phi\right) \land \psi \equiv \forall x \left(\phi \land \psi \right)$.
В планировщике используется альтернативный метод,
путем обхода дерева выражений с использованием \jar{поиск в глубину}.
Каждый раз, когда встречается \cd{Quantifier},
его тип и связанные переменные добавляются в список префикса
и заменяются в дереве на связанное выражение, которое он содержал.
Это приводит к корректному ПНФ, потому что несколько кванторов \textit{вложены} друг в друга,
то есть они применяются только к своему привязанному выражению.

Тем не менее, такое преобразование оставляет матрицу в свободной форме.
Чтобы сделать ее единообразной и предсказуемой, нам нужно применить дополнительные преобразования.
Совершенная ДНФ (СДНФ), которая содержит все предикаты в каждом из своих конъюнкций,
достигает обеих этих целей, а также предоставляет уникальное преимущество
для алгоритма \jar{инстанцирования}, о котором написано ниже.

СДНФ можно прочитать из таблицы истинности выражения,
поэтому первым шагом здесь является ее построение.
Таблица истинности не учитывает конкретные значения Предикатов,
а только то, какие Предикаты присутствуют в выражении.
Поэтому можно оценить выражение для каждой перестановки
истинных и ложных Предикатов, чтобы построить эту таблицу.
Затем создается конъюнкцию для каждой комбинации Предикатов,
которая делает формулу истинной,
добавляя в эту конъюнкцию каждый Предикат, который
был истинным в своем исходном виде
или его негативную версию, если он был ложным.
Уже существующий тип \cd{Primitives}
используется для представления этих двух вариантов,
однако сами конъюнкции не представляются отдельными структурами \cd{And} и \cd{Or},
вместо этого используюется структура множества из стандартной библиотеки Rust,
которые храним в новой структуре \cd{Dnf}.
Это снова подтверждает на этапе компиляции,
что выражение действительно находится в СДНФ.

При использовании их вместе, эти два подхода дают нам
\jar{Предваренную дизъюнктивную нормальную форму} (ПДНФ),
которое представлено как структура \cd{Pdnf}.
Она содержит префикс в виде списка \cd{Quantifiers} и матрицу в виде \cd{Dnf}.
Матрица, а значит и вся структура \cd{Pdnf}, является обобщенной по типу \cd{Predicate},
как и изначальное выражение.

\subsection{Действия}

Как уже было упомянуто ранее,
\pc{Действие} определяет преобразование состояния мира.
Это единственный способ перехода между состояниями,
и, следовательно, единственный способ решения задачи планирования.
Кроме имени, структура \cd{Action} содержит
список \cd{TypeHandles}, которые представляют аргументы для \cd{Action},
так же, как они представлены в \cd{Predicate};
для определения Предусловия используется \cd{Pdnf}, содержащаий \cd{LiftedPredicate},
а специальный тип \cd{ActionEffect} представляет Эффект,
который это действие может оказать на состояние.
Использование \cd{TypeHandles} для задания аргументов
и создание \cd{Pdnf} уже подробно описано,
поэтому единственным новым элементом в этом определении является \cd{ActionEffect}.

По необходимости Эффекты, которые может вызвать действие, ограничены
по сравнению с диапазоном, который может использовать Предусловие.
При изменении состояния не может быть неопределенности,
поэтому все, что можно упростить до выражения с \textit{ИЛИ},
запрещено. Квантор существования тоже запрещен.
Поэтому перечисление \cd{ActionEffect} позволяет использовать
соединитель \textit{И}, универсальный квантор, Предикат,
который может быть негативным, и специальное выражение \textit{when} (когда).

Выражение \textit{when} позволяет добавить дополнительные условия
непосредственно к Эффектам Действия.
Оно состоит из двух частей:
условия, которое может использовать логические связки,
из \cd{QuantifiedExpression},
и Эффекта, который рекурсивно использует \cd{ActionEffect} для фактических
изменений, которые нужно внести в состояние.
Ниже подробно рассказывается, как вычисляются и применяются Эффекты,
но прямо сейчас для выражения \textit{when} важно следующее.
При обработке Эффектов сначала оценивается условие
в текущем Состоянии, что легко сделать, так как на тот момент будет доступен
хотя бы один возможный способ, как это действие может быть инстанцированно в конкретном состоянии.
Если условие истинно, то предикаты в Эффекте
добавляются в полный список изменений, которые это действие вызывает,
или игнорируются в противном случае.

Для построения \cd{Action} используется еще один строитель с типовым состоянием.
Этот строитель сочетает идеи из двух предыдущих примеров.
Он определяет типы аргументов, для этог Действия, как \cd{PredicateBuilder},
и он определяет как Предусловие, так и Эффект с помощью замыканий,
которые принимают \cd{TypeHandles} и возвращают соответствующие выражения,
как \cd{QuantifierBuilder}.
Во время финализации в методе \cd{build()},
поочередно вызываются замыкания для создания Предусловия и Эффекта.
Если ошибок не возникло, то создается новое действие.
Если же что-то пошло не так при создании,
будь то ошибка предиката или ошибка парсинга,
финализация прерывается, и возвращается результатирующая ошибка.

\subsection{Состояние}

Структура \pc{State} определяет текущую истинную информацию о мире.
Это можно просто представить в планировщике набором \cd{GroundPredicates}.
Однако здесь используется оптимизацию,
которая, несмотря на свою простоту, значительно ускоряет поиск предикатов.
Вместо использования простого множества, которое содержит все истинные \cd{GroundPredicates},
они хранятся в ассоциативном массиве,
который использует имя предиката и количество параметров в качестве ключа,
а в качестве значения --- множество соответствующих предикатов.
Это позволяет избежать поиска по всем предикатам в состоянии.

Для создания \cd{State} не используется специальный строитель.
Вместо этого все истинные предикаты передаются в конструкторную функцию в виде множества.
Во время выполнения эта функция преобразует набор в эту оптимизированную структуру.

\subsection{Домен и проблема}

Структуры \pc{Domain} и \pc{Problem} в целом соответствуют
значению и определению домена и проблемы из PDDL.
Однако некоторые конструкции, такие как \jar{Ограничения} и \jar{Метрики},
исключены, так как они не так часто используются в планировании
и могут усложнить процесс планирования без явной пользы.

\pc{Домен} описывает, какие предикаты могут описывать состояние мира,
какие константы существуют в этом мире
и какие действия могут изменять его состояние и при каких условиях.
Структура \cd{Domain} состоит из имени, набора \jar{Требований},
которые определяют, какие аспекты PDDL необходимы для работы с этим доменом\footnotemark{},
\cd{EntityStorage}, который хранит как Типы, так и Объекты,
\cd{NamedStorage} для определения предикатов и еще одного \cd{NamedStorage} для действий.
Предикаты хранятся в неполной форме определения \cd{PredicateDefinition},
так как процесс их создания требует знания как типов аргументов,
так и значений, которые они будут принимать.
Однако в PDDL в декларации \cd{:predicates} дается только список аргументов с их типами,
поэтому финализация предиката откладывается до тех пор,
пока не будут получены значения, например, в определении действия или в части \cd{:init} проблемы.

\footnotetext{
  На момент написания этого текста, разработанный планировщик поддерживает большинство распространенных Требований.
  Однако он не поддерживает \pc{Fluents}, \pc{Durative actions},
  \pc{Derived predicates}, \pc{Preferences}, \pc{Constraints} и \pc{Action costs},
  так как они не так часто используются, трудны для реализации
  и не являются необходимыми для работы планировщика.
}

\pc{Задача} составляет вторую часть задачи планирования.
В Домене выражаются глобальные аспекты задачи,
такие как: какие Действия можно выполнить
и какие Типы объектов существуют в мире, в котором происходит планирование.
Задача же конкретизирует это, определяя, какие Объекты существуют,
что о них известно, и, наконец, какая цель должна быть достигнута.
Чтобы представить это в коде, помимо имени и имени домена,
структура \cd{Problem} содержит тот же \cd{EntityStorage},
который содержит дополнительные объекты, специфичные для данной проблемы,
помимо общих Констант, а также тот же \cd{NamedStorage} для действий.
Главное отличие от домена заключается в том,
что она хранит начальный \cd{State}
Цель, определенную как \cd{Pdnf} с \cd{ScopedPredicates}.
Важно, что цель не определяется как еще одно состояние,
а как выражение, которое должно быть истинным, чтобы планировщик завершил свою работу.

Для создания как \cd{Domain}, так и \cd{Problem}
используются два дополнительных строителя с типоавым состоянием.
Эти строители работают подобным образом, как и предыдущие строители.
За исключением указания требований,
единственный способ добавить новые типы, объекты, предикаты и т.д.
--- это использовать замыкания, как при определении Предусловия в Действии.
Однако эти замыкания немного сложнее.
Во-первых, строители передают им больше параметров,
например, при добавлении новых действий строитель передает
список указанных требований, \cd{ObjectStorage} и \cd{EntityStorage}
(которые являются двумя различными типажами, реализуемыми \cd{EntityStorage},
что позволяет более гибко управлять тем, что может делать вызывающий код),
\cd{NamedStorage} для определения предикатов
и изменяемый \cd{NamedStorage} для действий,
который изначально пустой и должен быть заполнен вызывающим кодом.
Этот пример также показывает,
что не все замыкания теперь возвращают результат.
Только при определении Цели используется замыкание,
которое возвращает \cd{QuantifiedFormula} или ошибку.
Другие замыкания не возвращают ничего при отсутствии ошибок,
вместо этого они модифицируют изменяемый параметр.
Это скрывает внутренние детали реализации хранилища
и не обременяет вызывающий код определением этих деталей самостоятельно.

\subsubsection{Парсинг}

Структуры \cd{Domain} и \cd{Problem} являются основными типами,
создаваемыми при чтении и парсинге соответствующих файлов PDDL.
Парсинг самого языка выходит за рамки данной работы,
поэтому эта задача решается уже существующей библиотекой \texttt{pddl}~\cite{pddl-crate}.
Эта библиотека позволяет парсить PDDL 3.1 на основе документации,
предоставленной Planning.Wiki~\cite{planning-wiki} и \textcite{kovacs2011complete}.

Файл парсится в структуру данных,
которая близка к \jar{Формe Бэкуса-Наура} (БНФ)~\cite{bnf} языка,
но она далека от того, чтобы быть полезной,
поэтому нам необходимо преобразовать её в собственные типы планирощика.
Благодаря рекурсивной природе БНФ и используемых типов, это довольно просто сделать.
Не будем вдаваться в детали этого процесса, но важно отметить,
что в ходе преобразования проверяется, что конструкции,
используемые для определения действий и цели, соответствуют указанным Требованиям.
Таким образом, не приходится верить, что файлы Домена и Проблемы созданы правильно,
потому что происходит отдельная проверка.
Поскольку не все алгоритмы планирования могут быть применены к каждому Домену,
гарантируется, что Требования правильно отражают содержимое Домена,
чтобы позже проверять их перед запуском алгоритмов планирования.

\section{Решение Проблемы}

Решении Проблемы состоит из двух основных алгоритмических компонент.
Первый компонент определяет способ приведения действия к конкретным объектам,
определённым в решаемой задаче --- \jar{инстанцирование}.
Это позволяет нам применить Эффект Действия к Состоянию,
добавляя или удаляя конкретные Предикаты из него.

Второй компонент --- это конкретная стратегия поиска,
используемая для нахождения пути через изменения Состояния.
В данной работе используется алгоритм A\*~\cite{astar} с эвристиками,
основанными на поиске в \jar{Граф планирования с упрощением}
(Relaxed Planning Graph, RPG)~\cite{BLUM1997281,Hoffmann_2001,bryce2007planninggraph}.
Однако используемый API достаточно гибкий,
чтобы поддерживать широкий спектр алгоритмов поиска и эвристик.

\subsection{Конкретизация Действия}

Алгоритм того, как Действие может быть применено к состоянию, можно описать следующим образом.
Сначала необходимо проверить, выполняется ли его Предусловие в текущем состоянии.
Это усложняется тем, что Предикаты, описывающие состояние,
являются \jar{инстанцированными}, что означает,
что их значения являются конкретными Объектами или Константами,
определёнными для этой Проблемы.
В то время как Предикаты в Предусловии действия \jar{обобщены}
--- они не являются конкретными, и, помимо констант, содержат переменные
в виде параметров Действия как значения.
Хотя параметры Действия ограничены их Типом, 
они могут быть инстанцированы несколькими Объектами.
Поэтому нужно найти такую комбинацию Объектов,
которая при подстановке этих Объектов в соответствующие параметры приведёт
Предусловие к \textit{истине}. Может быть несколько таких комбинаций или ни одной.
Если не существует ни одной подходящей подстановки,
это значит, что Действие не может быть применено к Состоянию.
Однако, если хотя бы одна такая комбинация найдена, нужно инстанцировать Эффект этого Действия,
потому что параметры Действия появляются и в них.
Это даёт список команд для изменения состояния (\cd{ModifyState}),
которые представляют собой простые команды для добавления или удаления
конкретных инстанцированных Предикатов из Состояния.

\subsubsection{Конкретизация Предусловия}

Для того чтобы проверить, выполняется ли Предусловие Действия в данном Состоянии,
необходимо реализовать механизм, который преобразует \cd{LiftedPredicates},
содержащие параметры действия, ограниченные Типами,
а также связанные переменные в кванторах, в \cd{GroundPredicates},
которые содержат только конкретные Объекты.
Для этого используется метод \cd{ground\_action()}, определенный для \cd{State}.
В этом методе каждая конъюнкция из матрицы ПДНФ Предусловия обрабатывается отдельно.
Это возможно сделать, потому что, как было сказано ранее,
алгоритм преобразования свободного выражения в ПДНФ создает полную СДНФ в матрице,
в которой все Предикаты присутствуют в каждом выражении.
Это также гарантирует, что все параметры Действия присутствуют в каждом выражении.
Это позволяет нам не беспокоиться о пропущенных параметрах.

Конъюнкция содержит несколько Предикатов, некоторые из которых могут быть отрицательными.
Для каждого положительного Предиката можно просто,
с какими объектами он встречается в данном Состоянии.
Это дает нам отображение от \cd{LiftedValues} (параметры действия и связанные переменные)
к нескольким Объектам, для которых этот предикат может быть оценен как \textit{истина};
Это отображение является инстанцированием отдельной конъюнкции,
а в коде оно называется \cd{Grounding}.
Для отрицательных Предикатов добавляется дополнительный шаг:
нам нужно найти все Объекты, для которых внутренний положительный Предикат
не может быть \textit{истинным}.
Этого можно достигнуть, \textit{инвертируя} положительное отображение:
вычитае положительное отображение из полного множества Объектов,
которые может принять конкретный параметр Действия или связанная переменная квантора.
Результатом этого будет отображение для отрицательного Предиката.
Для каждого Предиката в конъюнкции, получается \cd{Grounding}, а затем их объединение
является общим \cd{Grounding} для всей конъюнкции.
Если один и тот же \cd{LiftedValue} встречается в нескольких Предикатах
используем пересечения множеств, что гарантирует,
что все Предикаты будут истинными вместе.

На следующем шаге необходимо учесть префикс,
чтобы дополнительно уменьшить множество возможных \cd{Grounding}.
Для успешной оценки префикса необходимо убедиться,
что, в случае универсального квантора,
\cd{Grounding} содержит полное множество объектов для его связанной переменной,
а в случае экзистенциального квантора --- что оно содержит хотя бы один объект.
Однако префикс может содержать оба типа кванторов,
поэтому необходимо также учитывать их порядок.
Это требует проверки всех комбинаций связанных переменных.
Для каждой допустимой комбинации строится отображение от связанных переменных
к соответствующим объектам и проверяем, содержится ли оно в \cd{Grounding},
рассматривая вариант \cd{BoundVariable} в перечислимой структуре \cd{LiftedValue}.
Если все комбинации успешны, это означает,
что конъюнкция \textit{истинна} при условии префиксом,
и ее \cd{Grounding} добавляется в набор результатов функции.
Перебор всех возможных комбинаций --- неоптимален,
но это допустимо по следующим двум причинам:
\begin{enumerate}
  \item Кванторы редко встречаются в выражениях,
  \item Процесс проверки всех пермутаций прерывается,
    когда одна из них не проходит,
    что позволяет избежать лишних вычислений в случае,
    если конъюнкция не \textit{истинна} с данным префиксом.
\end{enumerate}

После этого удаляются связанные переменные из \cd{Grounding},
а затем объединяем все решения для отдельных конъюнкций в одно множество,
что является полным инстанцированием Предусловия.
Это дает нам несколько <<параллельных>> способов преобразования
обобщенного Действия в инстанцированное Действие.
В случае, если это множество пусто, можно сделать вывод,
что это Действие не может быть инстанцированно в текущем состоянии,
и не продолжаем с инстанцорованием его Эффекта.

\subsubsection{Конкретизация и применение Эффекта}

Следующий шаг генерирует список вариантов \cd{ModifyState},
которые затем используются для изменения Состояния.
Для этого используется полученное на предыдущем шаге \cd{Grounding},
чтобы сначала уплощать, а затем инстанцировать \cd{LiftedPredicates} в Эффекте Действия.
Для этого применяется метод \cd{ground\_effect()}.
В этом методе, для каждого <<параллельного>> \cd{Grounding},
рекурсивная структура \texttt{ActionEffect} обрабатывается,
и когда встречается \cd{Primitive} с \cd{LiftedPredicate},
он преобразуется в набор \cd{GroundPredicates}
для каждой комбинации параметров Действия и связанных переменных,
присутствующих в нем.

Вся структура уплощается в процессе этого преобразования,
что легко сделать, так как все соединители в ней представляют собой
логическую конъюнкцию.
Полученные \cd{Primitives} затем оборачиваются в варианты
перечисления \cd{ModifyState},
чтобы лучше передать желаемые модификации.
Как уже упоминалось, если встречается выражение \textit{when},
сначала оценивается условие в текущем Состоянии,
и если оно выполняется как \textit{true}, то продолжается уплощение его Эффекта.

К концу алгоритма получается набор наборов \cd{ModifyState}.
Они используются для изменения того, какие предикаты хранятся в текущем состоянии.
Более конкретно, \cd{Add} вариант добавляет \cd{GroundPredicate}
в \cd{State}, а \cd{Del} убирает соответствующий \cd{GroundPredicate}.
Эта операция идемпотентна, что значит,
что результат удаления несуществующего Предиката --- Состояние без него,
а добавление уже существующего Предиката --- Состояние,
где этот Предикат встречается только один раз.

\subsection{Поиск в графе состояний}

Типажы \cd{Solver} и \cd{Heuristic} составляют основу API,
которое позволяет планнеру поддерживать различные алгоритмы поиска и эвристики.
Оба эти типажа определяют метод \texttt{can\_solve()},
который принимает список Требований Домена и возвращает \cd{bool},
которое указывает, способен ли конкретный решатель или эвристика
обработать необходимые конструкции PDDL.

В дополнение к этому, \cd{Heuristic} также определяет метод \cd{prepare()},
который предварительно вычисляет значения,
необходимые для корректной и эффективной работы эвристики в ходе вычислений,
а также метод \cd{call()}, который оценивает Состояние.
Метод \cd{prepare()} необходим для эвристик,
которые требуют дополнительных вычислений до основного цикла планирования,
как, например, $h\_{add}$ или $h\_{max}$, 
для которых сначало нужно вычислить RPG.

Типаж \cd{Solver} имеет только один дополнительный метод --- \cd{solve()},
который принимает объекты \cd{Problem} и \cd{Heuristic},
и возвращает список из \cd{GroundAction},
состоящих из имени Действия и конкретных Объектов, с которыми оно было инстанцировано.
Оба типажа также определяют ассоциированный тип ошибки.
Конкретное определение типа зависит от вызывающего кода и представляет собой ошибки,
которые могут возникнуть в процессе подготовки эвристики или планирования соответственно.

\section{Экспериментальные результаты}

Для тестирования производительности Планировщика.
был подготовлен и выполнен набор тестов.
Основной целью являлась проверка производительности
Планировщика, а также его способность производить
корректные планы при обработке выражений с кванторами,
сложными логическими условиями и большим количеством объектов в Домене и Проблеме.
Эти тесты производительности играли дополнительную роль стресс-тестов системы.
Они позволили количественно оценить производительность
реализованного алгоритма планирования и выявить узкие места в архитектуре.

\begin{table}
  \centering
  \begin{footnotesize}
  \caption{Результаты тестов}
  \label{tab:benchresults}
    \begin{longtable}{|c|c|c|c|c|c|}
    \hline
      Название & Объекты & Предикаты & Действия & Кванторы & Ср. время (из 1000)\\
    \hline
    \hline
    simple & 4 & 4 & 3 & Нет & 83.410 µs\\
    \hline
    mini-warehouse & 7 & 5 & 4 & Да & 5.3849 ms\\
    \hline
    move-and-push & 26 & 6 & 8 & Нет & 670.39 ms\\
    \hline
  \end{longtable}
  \end{footnotesize}
\end{table}

Как видно из таблицы~\ref{tab:benchresults},
производительность одноагентного планировщика варьируется
в зависимости от сложности задач и используемых языковых конструкций.
В тесте \textit{simple} использовался минималистичный домен с тремя действиями,
четырьмя предикатами и базовыми STRIPS-операторами.
Цель состояла в том, чтобы переместить коробку
из одной комнаты в другую.
Эта задача была решена за в среднем 83.4 микросекунды,
что подтверждает высокую эффективность планировщика
в условиях простых, хорошо структурированных задач.
Следующий тест, \textit{mini-warehouse}, был направлен на проверку поддержки
более сложных конструкций PDDL: кванторов и условных эффектов.
Домен включал очистку смежных локаций,
а также управление несколькими объектами и их перемещением.
Несмотря на возросшую сложность, среднее время решения составило около 5.38 миллисекунд,
что указывает на приемлемую вычислительную нагрузку
при использовании расширенных возможностей языка.
Тест \textit{move-and-push} представлял собой наиболее сложный случай.
Он основан на модифицированном домене, описывающем игру Sokoban~\cite{enwiki:sokoban}.
В этом Домене используются отрицательные и дизъюнктивные предусловия,
большое количество объектов, а также сложные зависимости между ними.
Целью задачи было достижение конечного положения агента и объекта,
обходя препятствия и используя различные типы взаимодействия с объектами.
Среднее время решения составило 670.4 миллисекунды,
что отражает экспоненциальный рост сложности поиска в условиях
большого количества объектов и сильно разветвлённого пространства состояний.
Хотя этот показатель заметно выше предыдущих,
следует подчеркнуть, что увеличение времени обусловлено
в первую очередь самой структурой задачи и экспоненциальным ростом
пространства поиска --- а не недостатками реализации.

Основная сложность в этой задаче заключается в выборе эвристики:
она оказывает большое влияние на то, какую часть пространства состояний необходимо
просматривать.
В зависимости от того, как именно растет дерево состояний конкретной задачи,
изменяется эффективность используемых эвристик,
поэтому возможно, что текущая эвристика лучше работает для простых задач,
не имеющих большого числа объектов или сложных Предусловий, использующих кванторы.
Тем не менее, при переходе к более насыщенным задачам с высоким числом
взаимозависимых объектов и выраженной структурой причинно-следственных связей,
становится особенно актуальным применение более информативных и строгих эвристик.
Одной из таких является эвристика \jar{Landmark Cut}~\cite{lmcut} (LMCut),
которая основывается на последовательной оценке стоимости
достижения обязательных \jar{сечений} (cut) --- множеств действий,
необходимых для выполнения хотя бы одной из оставшихся целей.
В отличие от эвристик, основанных на удалении негативных эффектов,
таких как $h_{add}$ или $h_{max}$,
эвристика LMCut сохраняет допустимость оценки,
что особенно важно при построении оптимальных планов.
Кроме того, она способна точнее учитывать стоимость действий
в условиях, когда цели зависят от труднодостижимых промежуточных состояний
или могут быть достигнуты различными путями с различной ценой.
Несмотря на большую вычислительную нагрузку на каждом шаге,
применение LMCut может существенно сократить общее число расширяемых состояний
и повысить качество планов в задачах с высоким уровнем логической насыщенности.
Рассматривается возможность интеграции этой эвристики в архитектуру планировщика
в качестве альтернативного режима для задач, требующих строгой оценки стоимости.

Несмотря на неоптимальный выбор эвристика,
результаты демонстрируют, что предложенная реализация
эффективно справляется с широким спектром задач ---
от простых до высокоуровневых,
а также подтверждают пригодность архитектуры планировщика
для использования в реалистичных сценариях с различной степенью сложности.
